---
title: "Java Interview QA"
datePublished: Wed Oct 08 2025 13:12:06 GMT+0000 (Coordinated Universal Time)
cuid: cmgi0d0w4000102l21rvx78wq
slug: java-interview-qa
tags: codewithnini

---

# üíª **Core Java Interview Questions (300) for Automation Engineers**

---

## **1Ô∏è‚É£ Java Basics & Data Types (30 Qs)**

# 1.What are the features of Java?

# 2.Difference between JDK, JRE, JVM.

# 3.Why Java is platform-independent?

# 4.Difference between `==` and `.equals()`.

## **1Ô∏è‚É£** `==` Operator

* **Purpose:** Compares **references** (memory addresses) for objects or **values** for primitives.
    
* **Works For:** Primitives (int, boolean, etc.) and object references.
    
* **Returns:** `true` if both references point to the **same object** in memory.
    

**Example:**

```java
String s1 = "test";
String s2 = "test";
String s3 = new String("test");

System.out.println(s1 == s2); // true ‚Üí both refer to same string literal in pool
System.out.println(s1 == s3); // false ‚Üí s3 is a new object
```

* **Use in Automation:** Avoid using `==` to compare strings like expected vs actual values; it can give **false negatives**.
    

---

## **2Ô∏è‚É£** `.equals()` Method

* **Purpose:** Compares **contents/values** of objects.
    
* **Works For:** Objects that override `.equals()` (like `String`, `Integer`, `ArrayList`, etc.).
    
* **Returns:** `true` if **values are equal**, even if references are different.
    

**Example:**

```java
String s1 = "test";
String s3 = new String("test");

System.out.println(s1.equals(s3)); // true ‚Üí contents are the same
```

* **Use in Automation:** Always use `.equals()` to compare **strings, element text, API response values**, or any object content.
    

---

### **Quick Comparison Table**

| Feature | `==` | `.equals()` |
| --- | --- | --- |
| Compares | References (memory) | Values/contents |
| Works for | Primitives & objects | Objects (must override equals) |
| Returns | boolean | boolean |
| Example (String) | `s1 == s2` | `s1.equals(s2)` |
| Automation Use | Rarely for strings/objects | Always for strings, API values |

---

‚úÖ **Tip for Selenium/Automation:**

```java
String actual = driver.findElement(By.id("username")).getText();
String expected = "admin";

// Correct
if(actual.equals(expected)) {
    System.out.println("Text matches");
}

// Incorrect
if(actual == expected) {
    System.out.println("Text matches"); // Might fail unexpectedly
}
```

# 5.Difference between primitive and non-primitive data types.

1. Here‚Äôs the **short and clear difference**:
    
    ---
    
    | Feature | Primitive Data Types | Non-Primitive Data Types |
    | --- | --- | --- |
    | Examples | int, boolean, char, double | String, Array, Class, Interface |
    | Memory Storage | Stores **actual value** | Stores **reference/address** |
    | Default Value | 0, false, '\\u0000' | null |
    | Methods/Functions | **No methods** | **Has methods** |
    | Size | Fixed (e.g., int = 4 bytes) | Varies |
    | Null Assignment | Cannot be null | Can be null |
    
    **Example:**
    
    ```java
    int num = 10;       // primitive
    String name = "John"; // non-primitive
    ```
    
    **Automation Tip:** Use **primitives** for counters, flags; **non-primitives** for storing text, objects, or collections.
    
    # 6.What is the purpose of `main()` method?
    
    The `main()` method is the **entry point** of a Java program.  
    It is where the **JVM starts execution**.
    
    **Syntax:**
    
    ```java
    public static void main(String[] args) {
        // code execution starts here
    }
    ```
    
    **Key Points:**
    
    * `public` ‚Üí accessible by JVM.
        
    * `static` ‚Üí JVM can call it without creating an object.
        
    * `void` ‚Üí does not return any value.
        
    * `String[] args` ‚Üí used to pass command-line arguments.
        
    
    **Automation Tip:**  
    In Selenium/automation frameworks, `main()` is **rarely used**, as **TestNG/JUnit** or framework runners start execution.
    
    # 7.Can we overload `main()` method?
    
    **Short Answer:** ‚úÖ **Yes, we can overload** `main()` method in Java.
    
    **Explanation:**
    
    * JVM only calls the standard `public static void main(String[] args)`.
        
    * You can create other `main()` methods with **different parameters**.
        
    
    **Example:**
    
    ```java
    public class Test {
        public static void main(String[] args) {
            System.out.println("Standard main");
            main(10); // calling overloaded main
        }
    
        public static void main(int num) {
            System.out.println("Overloaded main: " + num);
        }
    }
    ```
    
    **Output:**
    
    ```java
    Standard main
    Overloaded main: 10
    ```
    
    **Automation Tip:**  
    Overloading `main()` is **rarely used in Selenium frameworks**; TestNG or JUnit handles execution instead.
    
    `main()` method cannot be overridden because it is `static`, and **static methods cannot be overridden** in Java.
    

# 8.Difference between `String`, `StringBuilder`, `StringBuffer`.

1. **1\. String**
    
    * **Immutable** ‚Üí cannot change once created.
        
    * **Thread-safe** by nature.
        
    * **Slower** if many modifications are needed.
        
    * Methods like `concat()` or `replace()` create **new objects**.
        
    * **Use in automation:** fixed test data, expected values, constants.
        
    
    **Example:**
    
    ```java
    String s = "Hello";
    s = s.concat(" World"); // creates new String object
    ```
    
    ---
    
    **2\. StringBuilder**
    
    * **Mutable** ‚Üí can modify content without creating new objects.
        
    * **Not thread-safe** ‚Üí faster than StringBuffer.
        
    * Methods: `append()`, `insert()`, `delete()`, `reverse()`.
        
    * **Use in automation:** building dynamic strings, logs, reports in **single-threaded execution**.
        
    
    **Example:**
    
    ```java
    StringBuilder sb = new StringBuilder("Hello");
    sb.append(" World"); // modifies same object
    ```
    
    ---
    
    **3\. StringBuffer**
    
    * **Mutable** ‚Üí can modify content.
        
    * **Thread-safe** ‚Üí synchronized, slower than StringBuilder.
        
    * Methods same as StringBuilder.
        
    * **Use in automation:** dynamic strings or logs in **multi-threaded tests**.
        
    
    **Example:**
    
    ```java
    StringBuffer sbf = new StringBuffer("Hello");
    sbf.append(" World"); // modifies same object
    ```
    
    ---
    
    **Summary:**
    
    * **String** ‚Üí immutable, thread-safe, slower for changes.
        
    * **StringBuilder** ‚Üí mutable, fast, single-threaded.
        
    * **StringBuffer** ‚Üí mutable, thread-safe, slower.
        
    
    # 9.What is immutable class in Java?
    
    An **immutable class** in Java is a class whose **objects cannot be modified after creation**.
    
    **Key Points:**
    
    1. Once the object is created, its **state (data) cannot change**.
        
    2. All **fields are declared** `private` and `final`.
        
    3. **No setter methods**; only getters.
        
    4. The class is declared `final` (optional but prevents subclass modification).
        
    5. Common example: `String` class.
        
    
    **Example:**
    
    ```java
    final class Employee {
        private final String name;
        private final int id;
    
        public Employee(String name, int id) {
            this.name = name;
            this.id = id;
        }
    
        public String getName() { return name; }
        public int getId() { return id; }
    }
    ```
    
    **Automation Tip:**
    
    * Immutable objects are **thread-safe**, useful for storing **constants, test data, or configuration values** in frameworks.
        
    
    # 10.Difference between stack and heap memory.
    
    Here‚Äôs the **short and clear difference** between **Stack and Heap memory** in Java:
    
    | Feature | Stack Memory | Heap Memory |
    | --- | --- | --- |
    | Storage | Stores **primitive variables** and **references to objects** | Stores **actual objects** and **class instances** |
    | Allocation | **Static** (at compile time) | **Dynamic** (at runtime) |
    | Lifetime | Exists until method execution ends | Exists until object is garbage collected |
    | Access Speed | **Faster** | **Slower** |
    | Thread Safety | Each thread has its own stack | Shared among all threads |
    | Example | Local variables in methods | Objects created using `new` keyword |
    
    **Automation Tip:**
    
    * Stack memory is used for **method calls, local variables**, while heap memory stores **WebElement objects, test data objects, and page objects** in Selenium frameworks.
        
    
    # 11.Difference between `final`, `finally`, `finalize`.
    
    Here‚Äôs the **short and clear difference** between `final`, `finally`, and `finalize` in Java:
    
    | Keyword | Purpose | Usage Example |
    | --- | --- | --- |
    | **final** | Used to make **class, method, or variable constant/unmodifiable** | `final int x = 10;`  
    `final class A {}`  
    `final void method() {}` |
    | **finally** | Block used in **exception handling**; always executes **after try-catch** | `try { int a=5/0; } catch(Exception e) {} finally { System.out.println("Done"); }` |
    | **finalize** | Method called by **garbage collector** before object is destroyed | `protected void finalize() { System.out.println("Object destroyed"); }` |
    
    **Automation Tip:**
    
    * `final` ‚Üí constants like **URLs, file paths**.
        
    * `finally` ‚Üí **close browser, quit driver, release resources**.
        
    * `finalize` ‚Üí rarely used; Java **garbage collection** handles cleanup.
        
    
    # 12.Difference between `break` and `continue`.
    
    Here‚Äôs the **short and clear difference** between `break` and `continue` in Java:
    
    | Keyword | Purpose | Behavior in Loop |
    | --- | --- | --- |
    | **break** | Exits the **entire loop** or **switch** immediately | Stops loop execution and moves **outside the loop** |
    | **continue** | Skips the **current iteration** and moves to the **next iteration** | Loop continues with the **next iteration** |
    
    **Example:**
    
    ```java
    for(int i=1; i<=5; i++){
        if(i==3) break;      // exits loop completely
        System.out.print(i); // Output: 12
    }
    
    for(int i=1; i<=5; i++){
        if(i==3) continue;   // skips current iteration
        System.out.print(i); // Output: 1245
    }
    ```
    
    **Automation Tip:**
    
    * Useful in **looping through WebElements**, **skipping failed steps**, or **breaking on certain condition** in Selenium scripts.
        
    
    # 13.Difference between `throw` and `throws`.
    
    Here‚Äôs the **short and clear difference** between `throw` and `throws` in Java:
    
    | Feature | `throw` | `throws` |
    | --- | --- | --- |
    | Purpose | Used to **actually throw an exception** | Used to **declare exception** in method signature |
    | Usage | Inside method body | After method declaration |
    | Number | Can throw **only one exception at a time** | Can declare **multiple exceptions** |
    | Checked/Unchecked | Can throw both | Can declare both |
    | Example | `throw new IOException("File not found");` | `void readFile() throws IOException {}` |
    
    **Automation Tip:**
    
    * `throw` ‚Üí used in **custom exception handling** in frameworks.
        
    * `throws` ‚Üí used to **declare exceptions** in utility or API methods to be handled by caller.
        
    
    # 14.What is typecasting? Example.
    
    **Typecasting** ‚Üí Converting a **variable from one data type to another**.
    
    ### **Types of Typecasting**
    
    1. **Widening (Implicit/Automatic)**
        
        * Converts **smaller type ‚Üí larger type**.
            
        * Done **automatically** by Java.
            
        * Example:
            
        
        ```java
        int i = 100;
        double d = i;  // int ‚Üí double (automatic)
        ```
        
    2. **Narrowing (Explicit/Manual)**
        
        * Converts **larger type ‚Üí smaller type**.
            
        * Requires **casting operator**.
            
        * Example:
            
        
        ```java
        double d = 100.5;
        int i = (int) d;  // double ‚Üí int (manual)
        ```
        
    
    **Automation Tip:**
    
    * Useful in Selenium when **converting numeric data from Excel/JSON** to required types for validation or calculations.
        
    
    # 15.Difference between implicit and explicit typecasting.
    
    Here‚Äôs the **short and clear difference** between **implicit** and **explicit typecasting** in Java:
    
    | Feature | Implicit Typecasting (Widening) | Explicit Typecasting (Narrowing) |
    | --- | --- | --- |
    | Also called | Widening conversion | Narrowing conversion |
    | Performed by | Java automatically | Programmer manually |
    | Converts | Smaller type ‚Üí Larger type | Larger type ‚Üí Smaller type |
    | Risk | Safe, no data loss | Risk of data loss |
    | Syntax | `int i = 10; double d = i;` | `double d = 10.5; int i = (int)d;` |
    | Example | `int ‚Üí long ‚Üí float ‚Üí double` | `double ‚Üí float ‚Üí long ‚Üí int` |
    
    **Automation Tip:**
    
    * **Implicit:** Auto conversion when reading test data (e.g., int ‚Üí double).
        
    * **Explicit:** Needed when validating numeric API response or converting large values to smaller types in Selenium framework.
        
    
    # **16\. What are literals in Java?**
    
    * **Literals** ‚Üí fixed values assigned to variables in code.
        
    * Types: **Integer (10), Floating (10.5), Character ('A'), String ("Hello"), Boolean (true/false)**.
        
    
    ---
    
    # **17.Difference between static and instance variables**
    
    | Feature | Static Variable | Instance Variable |
    | --- | --- | --- |
    | Belongs to | Class | Object |
    | Memory Allocation | Single copy in **heap** | Separate copy for each object |
    | Access | ClassName.variable | object.variable |
    | Lifetime | Till class is loaded | Till object exists |
    
    ---
    
    # **18\. Difference between static and non-static methods**
    
    | Feature | Static Method | Non-Static Method |
    | --- | --- | --- |
    | Belongs to | Class | Object |
    | Can access | Only static variables/methods | Both static and instance members |
    | Call without object | Yes | No, need object |
    | Override | Cannot override | Can override |
    
    ---
    
    # **19.Purpose of** `this` keyword
    
    * Refers to **current object**.
        
    * Used to **access instance variables, call other constructors**, or **pass current object**.
        
    
    **Example:**
    
    ```java
    class Test {
        int x;
        Test(int x) { this.x = x; }
    }
    ```
    
    ---
    
    # **20\. Purpose of** `super` keyword
    
    * Refers to **parent class object**.
        
    * Used to **access parent class methods, variables**, or **constructor**.
        
    
    **Example:**
    
    ```java
    class Parent { int x = 10; }
    class Child extends Parent {
        void show() { System.out.println(super.x); }
    }
    ```
    
    ---
    
    # **21\. Difference between access modifiers**
    
    | Modifier | Class | Package | Subclass | World |
    | --- | --- | --- | --- | --- |
    | **public** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
    | **private** | ‚úÖ | ‚ùå | ‚ùå | ‚ùå |
    | **protected** | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |
    | **default** | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå |
    
    ---
    
    # **22\. Difference between** `==` and `equalsIgnoreCase()` for Strings
    
    * `==` ‚Üí compares **references (memory)**.
        
    * `equalsIgnoreCase()` ‚Üí compares **string values ignoring case**.
        
    
    ---
    
    # **23\. Difference between** `char` and `Character`
    
    | Feature | char | Character |
    | --- | --- | --- |
    | Type | Primitive | Wrapper class |
    | Null Value | ‚ùå Not allowed | ‚úÖ Can be null |
    | Methods | ‚ùå None | ‚úÖ Methods like `isDigit()`, `isLetter()` |
    | Example | `char c = 'A';` | `Character ch = 'A';` |
    
    ---
    
    # **24\. What is wrapper class? Why is it used?**
    
    * **Wrapper class** ‚Üí Object representation of **primitive types**.
        
    * Used for:
        
        * Storing primitives in **collections** (e.g., `ArrayList<Integer>`).
            
        * Using **utility methods** like `parseInt()`, `valueOf()`.
            
    
    **Example:**
    
    ```java
    int i = 10;
    Integer obj = Integer.valueOf(i);
    ```
    
    ---
    
    # **25.Autoboxing and Unboxing in Java**
    
    * **Autoboxing:** Automatic conversion **primitive ‚Üí wrapper**.
        
    * **Unboxing:** Automatic conversion **wrapper ‚Üí primitive**.
        
    
    **Example:**
    
    ```java
    int i = 10;
    Integer obj = i;      // Autoboxing
    int j = obj;          // Unboxing
    ```
    
    # **26\. What is** `var` keyword in Java 10?
    
    * `var` ‚Üí used for **local variable type inference**.
        
    * Compiler **infers the type automatically** from the assigned value.
        
    * **Cannot be used** for instance variables, method parameters, or return type.
        
    
    **Example:**
    
    ```java
    var name = "John"; // Compiler infers String
    var num = 10;      // Compiler infers int
    ```
    
    ---
    
    # **27.Difference between** `null` and empty string
    
    | Feature | null | Empty String ("") |
    | --- | --- | --- |
    | Meaning | No object reference | Object exists, but no characters |
    | Length | ‚ùå Cannot check length | 0 |
    | Example | `String s = null;` | `String s = "";` |
    | Usage | Indicates **no value** | Indicates **blank value** |
    
    ---
    
    # **28.Difference between** `System.out.print` and `System.out.println`
    
    | Feature | `print()` | `println()` |
    | --- | --- | --- |
    | New line after output | ‚ùå No | ‚úÖ Yes |
    | Example | `System.out.print("Hi"); System.out.print("Bye"); // HiBye` | `System.out.println("Hi"); System.out.println("Bye"); // Hi\nBye` |
    
    ---
    
    # **29\. Default value of instance/static variables**
    
    | Data Type | Default Value |
    | --- | --- |
    | byte, short, int, long | 0 |
    | float, double | 0.0 |
    | char | '\\u0000' |
    | boolean | false |
    | Object (String, Array, etc.) | null |
    
    **Note:**
    
    * **Local variables** do **not have default values**; must be initialized.
        
    
    ---
    
    # **30\. What are command-line arguments?**
    
    * Values **passed to** `main()` method from the command line during program execution.
        
    * **Accessed via** `String[] args` array.
        
    
    **Example:**
    
    ```java
    public class Test {
        public static void main(String[] args) {
            System.out.println("First arg: " + args[0]);
        }
    }
    ```
    
    **Run:**
    
    ```java
    java Test Hello
    Output: First arg: Hello
    ```
    

---

## **2Ô∏è‚É£ Object-Oriented Programming (OOP) Concepts (40 Qs)**

# 1.What is OOP? Features of OOP.

### **What is OOP?**

**OOP (Object-Oriented Programming)** is a programming **paradigm based on objects** that **encapsulate data and behavior**.

* Focuses on **reusability, modularity, and maintainability**.
    
* Java is an **OOP language**.
    

---

### **Features of OOP**

| Feature | Description |
| --- | --- |
| **Encapsulation** | Wrapping data (variables) and methods in a **class**; controlled access using **private/public/protected**. |
| **Abstraction** | Hiding internal implementation; showing only **essential features** using **abstract classes/interfaces**. |
| **Inheritance** | Reusing code by deriving **child class** from **parent class**; promotes **hierarchy**. |
| **Polymorphism** | Ability to take multiple forms: **compile-time (method overloading)** and **runtime (method overriding)**. |
| **Class & Object** | **Class** ‚Üí blueprint; **Object** ‚Üí instance of class. |
| **Message Passing** | Objects interact by calling **methods** of other objects. |

---

# **2 Difference between Class and Object**

| Feature | Class | Object |
| --- | --- | --- |
| Definition | Blueprint or template | Instance of a class |
| Memory | Does not occupy memory | Occupies memory |
| Purpose | Defines properties & behavior | Stores actual data and methods |
| Example | `class LoginPage { ... }` | `LoginPage lp = new LoginPage();` |

---

# **3\. Difference between Abstraction and Encapsulation**

| Feature | Abstraction | Encapsulation |
| --- | --- | --- |
| Purpose | Hides implementation details | Hides internal data & controls access |
| Implementation | Abstract class / Interface | Access modifiers + getters/setters |
| Focus | What a class does | How data is accessed & protected |
| Automation Example | Abstract BaseTest class for setup/tearDown | Private WebElements in POM with public methods |

---

# **4\. Difference between Interface and Abstract Class**

| Feature | Interface | Abstract Class |
| --- | --- | --- |
| Multiple Inheritance | Supported | Not supported |
| Methods | Only abstract/default/static methods | Abstract + concrete methods |
| Variables | public static final only | Can have instance variables |
| Constructor | Cannot have | Can have |
| Automation Example | `IPageActions` interface for common page actions | `BasePage` abstract class with driver setup |

---

# **5\. When to use Abstract Class vs Interface in Automation Framework**

* **Abstract Class:**
    
    * When multiple methods share **common implementation**.
        
    * Example: `BaseTest` with setup/tearDown and common utilities.
        
* **Interface:**
    
    * When only **method signatures** are needed or **multiple inheritance** required.
        
    * Example: `IPageActions` for click, sendKeys, validate methods across pages.
        

---

# **6\. What is Inheritance? Types in Java**

* **Inheritance:** Ability to **reuse code** from parent class in child class.
    
* **Types:**
    
    1. **Single Inheritance:** `Parent ‚Üí Child`
        
    2. **Multilevel Inheritance:** `GrandParent ‚Üí Parent ‚Üí Child`
        
    3. **Hierarchical Inheritance:** One parent, multiple children
        
    4. **Hybrid Inheritance:** Combination (achieved via interface in Java)
        

---

# **7Ô∏è‚É£ Single vs Multilevel Inheritance**

| Feature | Single Inheritance | Multilevel Inheritance |
| --- | --- | --- |
| Levels | Parent ‚Üí Child | GrandParent ‚Üí Parent ‚Üí Child |
| Complexity | Simple | More complex |
| Example | `BaseTest ‚Üí LoginTest` | `BaseTest ‚Üí LoginPage ‚Üí HomePage` |

---

# **8Ô∏è‚É£ Difference between Method Overloading and Overriding**

| Feature | Overloading (Compile-time) | Overriding (Runtime) |
| --- | --- | --- |
| Method Name | Same | Same |
| Parameters | Must differ | Must be same |
| Return Type | Can differ (compatible) | Must be same (or covariant) |
| Access Modifier | Can vary | Cannot reduce visibility |
| Static Methods | Can overload | Cannot override |
| Automation Example | `login(String user)` & `login(String user, String pass)` | `takeScreenshot()` overridden in different pages |

---

# **9Ô∏è‚É£ Compile-time vs Runtime Polymorphism**

| Feature | Compile-time (Overloading) | Runtime (Overriding) |
| --- | --- | --- |
| Determined at | Compile-time | Runtime |
| Mechanism | Method overloading | Method overriding |
| Flexibility | Limited | High |
| Example (Automation) | `login(user)` vs `login(user, pass)` | `HomePage.takeScreenshot()` overridden from BasePage |

### **üîü What is Encapsulation? How is it used in POM?**

* **Encapsulation:** Wrapping **data (variables) and methods** together and controlling access using **private/public/protected**.
    
* **In POM:**
    
    * WebElements are **private**.
        
    * Public getter methods are used to **interact with elements**.
        

**Example:**

```java
public class LoginPage {
    private WebElement username;
    private WebElement password;

    public void enterUsername(String user) { username.sendKeys(user); }
    public void enterPassword(String pass) { password.sendKeys(pass); }
}
```

---

### **1Ô∏è‚É£1Ô∏è‚É£ What is Constructor? Types of Constructors**

* **Constructor:** Special method called **when object is created** to initialize it.
    
* **Types:**
    
    1. **Default constructor:** No parameters, provided by compiler.
        
    2. **Parameterized constructor:** Takes arguments to initialize objects.
        

**Example:**

```java
public class LoginPage {
    public LoginPage() { }                  // Default
    public LoginPage(WebDriver driver) { }  // Parameterized
}
```

---

### **1Ô∏è‚É£2Ô∏è‚É£ What is Constructor Chaining? Example in Framework**

* **Constructor Chaining:** Calling **one constructor from another** in same or parent class to reuse initialization.
    
* **Example in Framework:**
    

```java
public class BasePage {
    public BasePage(WebDriver driver) { }
}

public class LoginPage extends BasePage {
    public LoginPage(WebDriver driver) {
        super(driver);  // Calls parent constructor
    }
}
```

---

### **1Ô∏è‚É£3Ô∏è‚É£ What is super()? Example in POM**

* `super()` ‚Üí Calls **parent class constructor** or **parent methods/variables**.
    
* **Example in POM:**
    

```java
public class BasePage {
    WebDriver driver;
    public BasePage(WebDriver driver) { this.driver = driver; }
}

public class LoginPage extends BasePage {
    public LoginPage(WebDriver driver) {
        super(driver);  // Initializes driver in parent class
    }
}
```

---

### **1Ô∏è‚É£4Ô∏è‚É£ What is this()? Example in POM**

* `this()` ‚Üí Calls **another constructor in the same class**.
    
* **Example in POM:**
    

```java
public class LoginPage {
    WebDriver driver;
    public LoginPage() { this.driver = null; }
    public LoginPage(WebDriver driver) { this(); this.driver = driver; }
}
```

---

# **1Ô∏è‚É£5Ô∏è‚É£ Difference between Object Reference and Object Instance**

| Feature | Object Reference | Object Instance |
| --- | --- | --- |
| Definition | Variable that **refers to object** | Actual **object in memory** |
| Memory | Stores **address of object** | Stores **data and methods** |
| Example | `LoginPage lp;` | `new LoginPage();` |
| Complete Usage | `LoginPage lp = new LoginPage();` | `lp` points to the **instance** |

### **1Ô∏è‚É£6Ô∏è‚É£ Difference between Deep Copy and Shallow Copy**

| Feature | Shallow Copy | Deep Copy |
| --- | --- | --- |
| Copies | Reference only | Entire object + references |
| Memory | Shared | Separate memory |
| Changes in copy | Affect original | Do not affect original |
| Example | `Object clone()` (default) | Custom clone or serialization |

---

### **1Ô∏è‚É£7Ô∏è‚É£ Difference between Composition and Aggregation**

| Feature | Composition | Aggregation |
| --- | --- | --- |
| Life Cycle | Contained object dies with parent | Contained object can exist independently |
| Relationship | Strong HAS-A | Weak HAS-A |
| Example | Page ‚Üí WebElement | Driver ‚Üí Browser |

---

### **1Ô∏è‚É£8Ô∏è‚É£ What is Association in OOP?**

* **Association:** Relationship between **two independent classes**.
    
* Can be **one-to-one, one-to-many, many-to-many**.
    
* **Example:** Test ‚Üí WebDriver (uses driver, independent object)
    

---

### **1Ô∏è‚É£9Ô∏è‚É£ Difference between HAS-A and IS-A Relationship**

| Feature | HAS-A | IS-A |
| --- | --- | --- |
| Meaning | Composition/Aggregation | Inheritance |
| Example | Page HAS-A WebElements | LoginPage IS-A BasePage |

---

### **2Ô∏è‚É£0Ô∏è‚É£ How to implement Singleton Design Pattern in Selenium**

* **Singleton:** Ensures **single instance of a class** (e.g., WebDriver).
    
* **Example:**
    

```java
public class DriverManager {
    private static WebDriver driver;
    private DriverManager() { }
    public static WebDriver getDriver() {
        if(driver == null) driver = new ChromeDriver();
        return driver;
    }
}
```

---

### **2Ô∏è‚É£1Ô∏è‚É£ Difference between Static and Non-Static Block**

| Feature | Static Block | Non-Static Block |
| --- | --- | --- |
| Execution | Runs **once** at class loading | Runs **every time** object created |
| Purpose | Initialize static variables | Initialize instance variables |

---

### **2Ô∏è‚É£2Ô∏è‚É£ What is Method Hiding? Example**

* **Method Hiding:** When **child class defines a static method** with **same name as parent**.
    
* **Example:**
    

```java
class Base { static void show() { System.out.println("Base"); } }
class Child extends Base { static void show() { System.out.println("Child"); } }
```

---

### **2Ô∏è‚É£3Ô∏è‚É£ What is Runtime Polymorphism? Example in Automation**

* **Runtime Polymorphism:** Method overriding decided **at runtime**.
    
* **Example:**
    

```java
BasePage page = new LoginPage();
page.takeScreenshot(); // Executes overridden method in LoginPage
```

---

### **2Ô∏è‚É£4Ô∏è‚É£ Difference between Final Class, Final Method, Final Variable**

| Feature | Final Class | Final Method | Final Variable |
| --- | --- | --- | --- |
| Can inherit | ‚ùå No | ‚úÖ Yes (method only) | ‚ùå Cannot change |
| Can override | ‚ùå No | ‚ùå Cannot override | N/A |

---

### **2Ô∏è‚É£5Ô∏è‚É£ Difference between Object Cloning and Copy Constructor**

| Feature | Object Cloning | Copy Constructor |
| --- | --- | --- |
| Syntax | `clone()` method | Constructor with object as parameter |
| Control | Less control | More control over copying |
| Exception | Throws `CloneNotSupportedException` | No exception |

---

### **2Ô∏è‚É£6Ô∏è‚É£ What is Marker Interface? Example**

* **Marker Interface:** Interface with **no methods**, used for **tagging classes**.
    
* **Example:** `Serializable`, `Cloneable`
    

---

### **2Ô∏è‚É£7Ô∏è‚É£ Difference between Marker Interface and Functional Interface**

| Feature | Marker Interface | Functional Interface |
| --- | --- | --- |
| Methods | None | Exactly one abstract method |
| Purpose | Tagging/marker | Lambda expressions / method references |
| Example | `Serializable` | `Runnable` |

---

### **2Ô∏è‚É£8Ô∏è‚É£ What is Lambda Expression? Use in Selenium**

* **Lambda Expression:** Shorter way to define **functional interface implementation**.
    
* **Use in Selenium:** For **explicit waits, streams, and utilities**.
    

**Example:**

```java
List<WebElement> list = driver.findElements(By.tagName("a"));
list.forEach(ele -> System.out.println(ele.getText()));
```

---

### **2Ô∏è‚É£9Ô∏è‚É£ Difference between Anonymous Class and Lambda Expression**

| Feature | Anonymous Class | Lambda Expression |
| --- | --- | --- |
| Syntax | Verbose | Concise |
| Can access final vars | Yes | Yes |
| Usage | Single-use implementation | Functional interface, stream APIs |

---

### **3Ô∏è‚É£0Ô∏è‚É£ How to Use Functional Interface in Framework Utilities**

* Define **interface with one abstract method**.
    
* Implement with **lambda** for utilities like logging, reporting, filtering elements.
    

**Example:**

```java
@FunctionalInterface
interface Logger { void log(String message); }
Logger l = msg -> System.out.println(msg);
l.log("Test Started");
```

---

### **3Ô∏è‚É£1Ô∏è‚É£ Difference between Default and Static Method in Interface**

| Feature | Default Method | Static Method |
| --- | --- | --- |
| Called on | Object of implementing class | Interface name |
| Overridable | ‚úÖ Yes | ‚ùå No |
| Purpose | Common behavior | Utility method in interface |

---

### **3Ô∏è‚É£2Ô∏è‚É£ How Inheritance Works in Interface**

* An interface can **extend another interface**.
    
* Implementing class inherits **all abstract methods**.
    

---

### **3Ô∏è‚É£3Ô∏è‚É£ Can Interface Extend Another Interface?**

‚úÖ Yes, interfaces support **multiple inheritance**.

---

### **3Ô∏è‚É£4Ô∏è‚É£ Multiple Inheritance in Java ‚Äî Supported or Not?**

* **Class:** ‚ùå Not supported
    
* **Interface:** ‚úÖ Supported
    

---

### **3Ô∏è‚É£5Ô∏è‚É£ Difference between Abstract Class and Normal Class**

| Feature | Abstract Class | Normal Class |
| --- | --- | --- |
| Instantiation | ‚ùå Cannot create object | ‚úÖ Can create object |
| Abstract Method | Can have | ‚ùå Cannot have |
| Inheritance | Can be extended | Can be extended |

---

### **3Ô∏è‚É£6Ô∏è‚É£ Can We Create Object of Abstract Class?**

‚ùå No, only subclass objects can be created.

---

### **3Ô∏è‚É£7Ô∏è‚É£ Difference between Final and Abstract Classes**

| Feature | Final Class | Abstract Class |
| --- | --- | --- |
| Inheritance | ‚ùå Cannot be extended | ‚úÖ Can be extended |
| Purpose | Prevent inheritance | Provide base for subclasses |

---

### **3Ô∏è‚É£8Ô∏è‚É£ Difference between Overloading and Overriding in WebDriver Context**

| Feature | Overloading | Overriding |
| --- | --- | --- |
| Example | `click(WebElement)` vs `click(By)` | `takeScreenshot()` overridden in LoginPage |
| Compile vs Runtime | Compile-time | Runtime |

---

### **3Ô∏è‚É£9Ô∏è‚É£ How to Implement Page Navigation using OOPs (BasePage ‚Üí ChildPage)**

```java
public class BasePage {
    WebDriver driver;
    public BasePage(WebDriver driver) { this.driver = driver; }
    public void open(String url) { driver.get(url); }
}

public class LoginPage extends BasePage {
    public LoginPage(WebDriver driver) { super(driver); }
    public HomePage login(String user, String pass) {
        // enter credentials
        return new HomePage(driver); // navigate to HomePage
    }
}
```

---

### **4Ô∏è‚É£0Ô∏è‚É£ Use of Encapsulation for WebElements in POM**

* **WebElements are private**.
    
* **Public methods** to interact with them.
    
* Ensures **data hiding** and **controlled access**.
    

```java
private WebElement username;
public void enterUsername(String user) { username.sendKeys(user); }
```

---

## **3Ô∏è‚É£ Exception Handling (20 Qs)**

1. Difference between checked and unchecked exception.
    
2. Common Selenium exceptions (NoSuchElementException, TimeoutException, StaleElementReferenceException).
    
3. When does ElementNotInteractableException occur?
    
4. Difference between throw and throws.
    
5. How to handle exceptions globally in framework?
    
6. What is finally block? Example.
    
7. Difference between Exception and Error.
    
8. How to create custom exception? Example.
    
9. How to retry failed test cases using Java + TestNG.
    
10. What is InterruptedException and how to handle it in thread sleep?
    
11. How to handle stale element exception dynamically.
    
12. How to handle NoSuchFrameException.
    
13. How to handle ElementClickInterceptedException.
    
14. How to handle Javascript errors in Selenium.
    
15. How to handle multiple exceptions in single try-catch.
    
16. Difference between throw and rethrow.
    
17. Difference between Exception, RuntimeException, and Throwable.
    
18. How to capture stack trace in Selenium logs.
    
19. How to handle alert not present exception.
    
20. How to implement retry logic with screenshot capture on failure.
    

---

## **4Ô∏è‚É£ Strings & Collections (35 Qs)**

1. Difference between String, StringBuffer, StringBuilder.
    
2. How to split a string in Java.
    
3. How to remove leading/trailing spaces.
    
4. How to reverse a string.
    
5. How to compare strings ignoring case.
    
6. How to extract numeric values from text (e.g., price).
    
7. How to convert List&lt;WebElement&gt; to List&lt;String&gt;.
    
8. How to iterate List&lt;WebElements&gt;.
    
9. Difference between List, Set, Map.
    
10. HashMap vs Hashtable.
    
11. ConcurrentHashMap use case in parallel execution.
    
12. Difference between HashSet and TreeSet.
    
13. How to remove duplicates from List.
    
14. How to sort List of WebElements alphabetically.
    
15. Difference between Iterator and ListIterator.
    
16. Difference between fail-fast and fail-safe iterators.
    
17. How to filter elements using Stream API.
    
18. How to map WebElements to attribute values.
    
19. Difference between keySet(), entrySet(), values() in Map.
    
20. How to search an element in HashMap.
    
21. How to handle dynamic test data using collections.
    
22. How to store test data in Map for key-value lookup.
    
23. How to merge two Maps.
    
24. How to count duplicate elements in List.
    
25. How to find max/min value in List of integers.
    
26. Difference between Array and ArrayList.
    
27. How to convert Array to ArrayList.
    
28. How to convert ArrayList to Array.
    
29. Difference between LinkedList and ArrayList.
    
30. Difference between Stack and Queue.
    
31. How to implement Queue in Selenium waits.
    
32. How to use PriorityQueue in framework.
    
33. Difference between Deque and Queue.
    
34. How to use HashMap to store element locator dynamically.
    
35. How to use Streams for filtering and sorting elements.
    

---

## **5Ô∏è‚É£ File Handling & Data-Driven Testing (25 Qs)**

1. How to read/write from property files.
    
2. How to read Excel using Apache POI.
    
3. How to read JSON test data.
    
4. How to write logs to file.
    
5. How to capture screenshots.
    
6. How to store screenshots in date-wise folder.
    
7. How to upload a file using sendKeys.
    
8. How to verify downloaded file.
    
9. How to read multiple rows from Excel.
    
10. Difference between FileInputStream and FileReader.
    
11. Difference between BufferedReader and Scanner.
    
12. How to read environment-specific properties dynamically.
    
13. How to handle CSV files in Java.
    
14. How to convert JSON array to List&lt;String&gt;.
    
15. How to use try-with-resources for file handling.
    
16. How to read config dynamically for multiple environments.
    
17. How to create logs using Log4j in framework.
    
18. Difference between synchronous and asynchronous file writes.
    
19. How to handle Excel formulas in POI.
    
20. How to validate file existence before upload.
    
21. How to append logs instead of overwrite.
    
22. How to read multiple sheets in Excel.
    
23. How to write test results in Excel dynamically.
    
24. How to read binary files in Java.
    
25. How to validate JSON response structure from API.
    

---

## **6Ô∏è‚É£ Multithreading & Parallel Execution (25 Qs)**

1. What is multi-threading?
    
2. How does TestNG use multi-threading.
    
3. Difference between parallel and sequential execution.
    
4. How to make WebDriver thread-safe using ThreadLocal.
    
5. Difference between synchronized block and method.
    
6. How to handle shared resources in parallel tests.
    
7. How to implement thread-safe singleton driver.
    
8. Difference between Runnable and Thread class.
    
9. Difference between yield(), sleep(), join().
    
10. Difference between wait() and sleep().
    
11. How to run tests in parallel in TestNG.
    
12. How to implement parallel browser execution.
    
13. How to handle data collisions in multi-threaded tests.
    
14. Difference between volatile and ThreadLocal.
    
15. Difference between AtomicInteger and Integer.
    
16. How to handle logging in parallel tests.
    
17. How to handle dynamic reports in parallel execution.
    
18. Difference between concurrency and parallelism.
    
19. How to synchronize methods in utility classes.
    
20. How to handle DB connections in parallel tests.
    
21. Difference between CountDownLatch and CyclicBarrier.
    
22. Difference between ExecutorService and ThreadPool.
    
23. How to terminate threads gracefully.
    
24. How to handle InterruptedException.
    
25. How to implement retry for flaky tests in parallel execution.
    

---

## **7Ô∏è‚É£ Real-World Framework Design & Scenario Questions (50 Qs)**

1. How to implement Singleton WebDriver class.
    
2. How to implement BasePage and ChildPage in POM.
    
3. How to implement Utility class for reusable methods.
    
4. How to implement RetryAnalyzer in TestNG.
    
5. How to capture logs and screenshots on failure.
    
6. How to handle dynamic locators.
    
7. How to handle stale elements dynamically.
    
8. How to select value from dynamic dropdown.
    
9. How to handle multiple windows.
    
10. How to handle alerts and popups.
    
11. How to handle frames and iframes.
    
12. How to verify table contents dynamically.
    
13. How to scroll to element using JavaScriptExecutor.
    
14. How to perform mouse hover and drag-drop.
    
15. How to implement data-driven testing from Excel/JSON.
    
16. How to validate API response on UI.
    
17. How to implement custom wait utilities.
    
18. How to handle checkboxes and radio buttons dynamically.
    
19. How to verify broken links on a page.
    
20. How to run parallel browser tests (Chrome + Firefox).
    
21. How to integrate Selenium with Maven.
    
22. How to generate TestNG/Extent reports dynamically.
    
23. How to implement IRetryAnalyzer for flaky tests.
    
24. How to implement PageFactory in POM.
    
25. How to handle dynamic tables with sorting/filtering.
    
26. How to handle shadow DOM elements.
    
27. How to validate UI elements against DB values.
    
28. How to validate UI elements against API values.
    
29. How to implement BaseTest with setup and teardown methods.
    
30. How to implement reusable wait methods.
    
31. How to verify dynamic error messages.
    
32. How to handle hidden elements using JSExecutor.
    
33. How to implement cross-browser testing using WebDriverFactory.
    
34. How to implement thread-safe reporting.
    
35. How to implement parallel execution with ITestListener.
    
36. How to validate dynamic charts on UI.
    
37. How to validate dynamic pagination.
    
38. How to validate tooltip messages.
    
39. How to handle auto-suggest dropdowns.
    
40. How to implement soft assertions in framework.
    
41. How to integrate Selenium with Rest-Assured.
    
42. How to validate API response in UI automation.
    
43. How to handle SSL certificate warnings.
    
44. How to validate dynamic date pickers.
    
45. How to handle dynamic popups in framework.
    
46. How to implement reusable dropdown selection.
    
47. How to implement fluent wait for dynamic elements.
    
48. How to implement custom ExpectedConditions.
    
49. How to capture dynamic screenshots based on test name.
    
50. How to implement environment-specific test configuration.
    

---

## **8Ô∏è‚É£ Java 8 Features in Automation (25 Qs)**

1. Lambda expressions ‚Äî usage in filtering elements.
    
2. Functional interfaces ‚Äî example in utilities.
    
3. Stream API ‚Äî filter, map, collect.
    
4. Map WebElements to Strings using Stream.
    
5. Sort WebElements using Stream API.
    
6. Parallel Stream vs Sequential Stream.
    
7. Optional class ‚Äî avoid NullPointerException.
    
8. Method references ‚Äî `WebElement::getText`.
    
9. Default methods in interface.
    
10. Static methods in interface.
    
11. How to use Streams with Maps.
    
12. Filter Map entries using Stream.
    
13. Count elements matching criteria using Stream.
    
14. Find first element using Stream.
    
15. Sum values from list using Stream.
    
16. Max/Min using Stream.
    
17. Distinct values using Stream.
    
18. Grouping elements using Stream.
    
19. Joining strings using Stream.
    
20. Limit and skip in Stream.
    
21. AnyMatch/AllMatch/NoneMatch usage.
    
22. Reduce method in Stream.
    
23. How to handle null in Stream using Optional.
    
24. How to apply Stream API in reports.
    
25. How to use Stream API in API response validation.
    

---

## **9Ô∏è‚É£ Core Java + Selenium Scenarios (50 Qs)**

1. Dynamic ID handling.
    
2. StaleElementReferenceException.
    
3. ElementNotInteractableException.
    
4. TimeoutException scenario.
    
5. Handling multiple windows.
    
6. Handling frames and iframes.
    
7. Handling alerts.
    
8. File upload/download.
    
9. Broken links validation.
    
10. Dynamic dropdown selection.
    
11. Scroll to element using JSExecutor.
    
12. Hover actions using Actions class.
    
13. Drag and drop scenario.
    
14. Capturing screenshots on failure.
    
15. Implicit vs Explicit vs Fluent waits.
    
16. Handling auto-suggest dropdown.
    
17. Dynamic table verification.
    
18. Pagination verification.
    
19. Tooltip validation.
    
20. Chart validation.
    
21. Handling shadow DOM elements.
    
22. Cross-browser execution scenario.
    
23. Parallel execution scenario.
    
24. Flaky test retry scenario.
    
25. Thread-safe WebDriver scenario.
    
26. Data-driven login scenario.
    
27. API response validation scenario.
    
28. Dynamic error message validation.
    
29. Hidden element handling scenario.
    
30. Soft assertion scenario.
    
31. JavaScriptExecutor click scenario.
    
32. Handling dynamic modals.
    
33. Environment-specific config handling.
    
34. Validating multiple elements text dynamically.
    
35. Reading dynamic Excel/JSON for test data.
    
36. Synchronization issue scenario.
    
37. Handling InterruptedException.
    
38. Handling dynamic wait polling interval.
    
39. List&lt;WebElement&gt; filtering scenario.
    
40. Verifying multiple links dynamically.
    
41. Lambda expression scenario in Selenium.
    
42. Stream API scenario for filtering elements.
    
43. Optional usage scenario.
    
44. Map test data validation scenario.
    
45. Collection sorting scenario.
    
46. Collection duplicate removal scenario.
    
47. Dynamic screenshot naming scenario.
    
48. Retry mechanism scenario in TestNG.
    
49. Logging scenario using Log4j.
    
50. Parallel report generation scenario.
    

---

**‚úÖ Total Questions:** 300+ (all Java core + automation-related + scenarios)