---
title: "Java Interview QA"
datePublished: Wed Oct 08 2025 13:12:06 GMT+0000 (Coordinated Universal Time)
cuid: cmgi0d0w4000102l21rvx78wq
slug: java-interview-qa
tags: codewithnini

---

# üíª **Core Java Interview Questions (300) for Automation Engineers**

---

## **1Ô∏è‚É£ Java Basics & Data Types (30 Qs)**

# 1.What are the features of Java?

# 2.Difference between JDK, JRE, JVM.

# 3.Why Java is platform-independent?

# 4.Difference between `==` and `.equals()`.

## **1Ô∏è‚É£** `==` Operator

* **Purpose:** Compares **references** (memory addresses) for objects or **values** for primitives.
    
* **Works For:** Primitives (int, boolean, etc.) and object references.
    
* **Returns:** `true` if both references point to the **same object** in memory.
    

**Example:**

```java
String s1 = "test";
String s2 = "test";
String s3 = new String("test");

System.out.println(s1 == s2); // true ‚Üí both refer to same string literal in pool
System.out.println(s1 == s3); // false ‚Üí s3 is a new object
```

* **Use in Automation:** Avoid using `==` to compare strings like expected vs actual values; it can give **false negatives**.
    

---

## **2Ô∏è‚É£** `.equals()` Method

* **Purpose:** Compares **contents/values** of objects.
    
* **Works For:** Objects that override `.equals()` (like `String`, `Integer`, `ArrayList`, etc.).
    
* **Returns:** `true` if **values are equal**, even if references are different.
    

**Example:**

```java
String s1 = "test";
String s3 = new String("test");

System.out.println(s1.equals(s3)); // true ‚Üí contents are the same
```

* **Use in Automation:** Always use `.equals()` to compare **strings, element text, API response values**, or any object content.
    

---

### **Quick Comparison Table**

| Feature | `==` | `.equals()` |
| --- | --- | --- |
| Compares | References (memory) | Values/contents |
| Works for | Primitives & objects | Objects (must override equals) |
| Returns | boolean | boolean |
| Example (String) | `s1 == s2` | `s1.equals(s2)` |
| Automation Use | Rarely for strings/objects | Always for strings, API values |

---

‚úÖ **Tip for Selenium/Automation:**

```java
String actual = driver.findElement(By.id("username")).getText();
String expected = "admin";

// Correct
if(actual.equals(expected)) {
    System.out.println("Text matches");
}

// Incorrect
if(actual == expected) {
    System.out.println("Text matches"); // Might fail unexpectedly
}
```

# 5.Difference between primitive and non-primitive data types.

1. Here‚Äôs the **short and clear difference**:
    
    ---
    
    | Feature | Primitive Data Types | Non-Primitive Data Types |
    | --- | --- | --- |
    | Examples | int, boolean, char, double | String, Array, Class, Interface |
    | Memory Storage | Stores **actual value** | Stores **reference/address** |
    | Default Value | 0, false, '\\u0000' | null |
    | Methods/Functions | **No methods** | **Has methods** |
    | Size | Fixed (e.g., int = 4 bytes) | Varies |
    | Null Assignment | Cannot be null | Can be null |
    
    **Example:**
    
    ```java
    int num = 10;       // primitive
    String name = "John"; // non-primitive
    ```
    
    **Automation Tip:** Use **primitives** for counters, flags; **non-primitives** for storing text, objects, or collections.
    
    # 6.What is the purpose of `main()` method?
    
    The `main()` method is the **entry point** of a Java program.  
    It is where the **JVM starts execution**.
    
    **Syntax:**
    
    ```java
    public static void main(String[] args) {
        // code execution starts here
    }
    ```
    
    **Key Points:**
    
    * `public` ‚Üí accessible by JVM.
        
    * `static` ‚Üí JVM can call it without creating an object.
        
    * `void` ‚Üí does not return any value.
        
    * `String[] args` ‚Üí used to pass command-line arguments.
        
    
    **Automation Tip:**  
    In Selenium/automation frameworks, `main()` is **rarely used**, as **TestNG/JUnit** or framework runners start execution.
    
    # 7.Can we overload `main()` method?
    
    **Short Answer:** ‚úÖ **Yes, we can overload** `main()` method in Java.
    
    **Explanation:**
    
    * JVM only calls the standard `public static void main(String[] args)`.
        
    * You can create other `main()` methods with **different parameters**.
        
    
    **Example:**
    
    ```java
    public class Test {
        public static void main(String[] args) {
            System.out.println("Standard main");
            main(10); // calling overloaded main
        }
    
        public static void main(int num) {
            System.out.println("Overloaded main: " + num);
        }
    }
    ```
    
    **Output:**
    
    ```java
    Standard main
    Overloaded main: 10
    ```
    
    **Automation Tip:**  
    Overloading `main()` is **rarely used in Selenium frameworks**; TestNG or JUnit handles execution instead.
    
    `main()` method cannot be overridden because it is `static`, and **static methods cannot be overridden** in Java.
    

# 8.Difference between `String`, `StringBuilder`, `StringBuffer`.

1. **1\. String**
    
    * **Immutable** ‚Üí cannot change once created.
        
    * **Thread-safe** by nature.
        
    * **Slower** if many modifications are needed.
        
    * Methods like `concat()` or `replace()` create **new objects**.
        
    * **Use in automation:** fixed test data, expected values, constants.
        
    
    **Example:**
    
    ```java
    String s = "Hello";
    s = s.concat(" World"); // creates new String object
    ```
    
    ---
    
    **2\. StringBuilder**
    
    * **Mutable** ‚Üí can modify content without creating new objects.
        
    * **Not thread-safe** ‚Üí faster than StringBuffer.
        
    * Methods: `append()`, `insert()`, `delete()`, `reverse()`.
        
    * **Use in automation:** building dynamic strings, logs, reports in **single-threaded execution**.
        
    
    **Example:**
    
    ```java
    StringBuilder sb = new StringBuilder("Hello");
    sb.append(" World"); // modifies same object
    ```
    
    ---
    
    **3\. StringBuffer**
    
    * **Mutable** ‚Üí can modify content.
        
    * **Thread-safe** ‚Üí synchronized, slower than StringBuilder.
        
    * Methods same as StringBuilder.
        
    * **Use in automation:** dynamic strings or logs in **multi-threaded tests**.
        
    
    **Example:**
    
    ```java
    StringBuffer sbf = new StringBuffer("Hello");
    sbf.append(" World"); // modifies same object
    ```
    
    ---
    
    **Summary:**
    
    * **String** ‚Üí immutable, thread-safe, slower for changes.
        
    * **StringBuilder** ‚Üí mutable, fast, single-threaded.
        
    * **StringBuffer** ‚Üí mutable, thread-safe, slower.
        
    
    # 9.What is immutable class in Java?
    
    An **immutable class** in Java is a class whose **objects cannot be modified after creation**.
    
    **Key Points:**
    
    1. Once the object is created, its **state (data) cannot change**.
        
    2. All **fields are declared** `private` and `final`.
        
    3. **No setter methods**; only getters.
        
    4. The class is declared `final` (optional but prevents subclass modification).
        
    5. Common example: `String` class.
        
    
    **Example:**
    
    ```java
    final class Employee {
        private final String name;
        private final int id;
    
        public Employee(String name, int id) {
            this.name = name;
            this.id = id;
        }
    
        public String getName() { return name; }
        public int getId() { return id; }
    }
    ```
    
    **Automation Tip:**
    
    * Immutable objects are **thread-safe**, useful for storing **constants, test data, or configuration values** in frameworks.
        
    
    # 10.Difference between stack and heap memory.
    
    Here‚Äôs the **short and clear difference** between **Stack and Heap memory** in Java:
    
    | Feature | Stack Memory | Heap Memory |
    | --- | --- | --- |
    | Storage | Stores **primitive variables** and **references to objects** | Stores **actual objects** and **class instances** |
    | Allocation | **Static** (at compile time) | **Dynamic** (at runtime) |
    | Lifetime | Exists until method execution ends | Exists until object is garbage collected |
    | Access Speed | **Faster** | **Slower** |
    | Thread Safety | Each thread has its own stack | Shared among all threads |
    | Example | Local variables in methods | Objects created using `new` keyword |
    
    **Automation Tip:**
    
    * Stack memory is used for **method calls, local variables**, while heap memory stores **WebElement objects, test data objects, and page objects** in Selenium frameworks.
        
    
    # 11.Difference between `final`, `finally`, `finalize`.
    
    Here‚Äôs the **short and clear difference** between `final`, `finally`, and `finalize` in Java:
    
    | Keyword | Purpose | Usage Example |
    | --- | --- | --- |
    | **final** | Used to make **class, method, or variable constant/unmodifiable** | `final int x = 10;`  
    `final class A {}`  
    `final void method() {}` |
    | **finally** | Block used in **exception handling**; always executes **after try-catch** | `try { int a=5/0; } catch(Exception e) {} finally { System.out.println("Done"); }` |
    | **finalize** | Method called by **garbage collector** before object is destroyed | `protected void finalize() { System.out.println("Object destroyed"); }` |
    
    **Automation Tip:**
    
    * `final` ‚Üí constants like **URLs, file paths**.
        
    * `finally` ‚Üí **close browser, quit driver, release resources**.
        
    * `finalize` ‚Üí rarely used; Java **garbage collection** handles cleanup.
        
2. Difference between `break` and `continue`.
    
3. Difference between `throw` and `throws`.
    
4. What is typecasting? Example.
    
5. Difference between implicit and explicit typecasting.
    
6. What are literals in Java?
    
7. Difference between `static` and instance variables.
    
8. Difference between `static` and non-static methods.
    
9. Purpose of `this` keyword.
    
10. Purpose of `super` keyword.
    
11. Difference between `public`, `private`, `protected`, default access modifiers.
    
12. Difference between `==` and `equalsIgnoreCase()` for Strings.
    
13. Difference between `char` and `Character` class.
    
14. What is wrapper class? Why is it used?
    
15. Autoboxing and unboxing in Java.
    
16. What is `var` keyword in Java 10?
    
17. Difference between `null` and empty string.
    
18. Difference between `System.out.print` and `System.out.println`.
    
19. What is the default value of instance/static variables?
    
20. What are command-line arguments?
    

---

## **2Ô∏è‚É£ Object-Oriented Programming (OOP) Concepts (40 Qs)**

1. What is OOP? Features of OOP.
    
2. Difference between class and object.
    
3. Difference between abstraction and encapsulation.
    
4. Difference between interface and abstract class.
    
5. When to use abstract class vs interface in automation framework.
    
6. What is inheritance? Types in Java.
    
7. Single vs multi-level inheritance.
    
8. Difference between method overloading and overriding.
    
9. Compile-time vs runtime polymorphism.
    
10. What is encapsulation? How is it used in Page Object Model (POM)?
    
11. What is constructor? Types of constructors.
    
12. What is constructor chaining? Example in framework.
    
13. What is `super()`? Example in POM.
    
14. What is `this()`? Example in POM.
    
15. Difference between object reference and object instance.
    
16. Difference between deep copy and shallow copy.
    
17. Difference between composition and aggregation.
    
18. What is association in OOP?
    
19. Difference between HAS-A and IS-A relationship.
    
20. How do you implement singleton design pattern in Selenium framework?
    
21. Difference between static and non-static block.
    
22. What is method hiding? Example.
    
23. What is runtime polymorphism? Example in automation.
    
24. Difference between final class, final method, final variable.
    
25. Difference between object cloning and copy constructor.
    
26. What is marker interface? Example.
    
27. Difference between marker interface and functional interface.
    
28. What is lambda expression? Use in Selenium.
    
29. Difference between anonymous class and lambda expression.
    
30. How to use functional interface in framework utilities?
    
31. Difference between `default` and `static` method in interface.
    
32. How inheritance works in interface?
    
33. Can interface extend another interface?
    
34. Multiple inheritance in Java ‚Äî supported or not?
    
35. Difference between abstract class and normal class.
    
36. Can we create object of abstract class?
    
37. Difference between final and abstract classes.
    
38. Difference between overloading and overriding in context of WebDriver actions.
    
39. How to implement page navigation using OOPs (BasePage ‚Üí ChildPage)?
    
40. Use of encapsulation for WebElements in POM.
    

---

## **3Ô∏è‚É£ Exception Handling (20 Qs)**

1. Difference between checked and unchecked exception.
    
2. Common Selenium exceptions (NoSuchElementException, TimeoutException, StaleElementReferenceException).
    
3. When does ElementNotInteractableException occur?
    
4. Difference between throw and throws.
    
5. How to handle exceptions globally in framework?
    
6. What is finally block? Example.
    
7. Difference between Exception and Error.
    
8. How to create custom exception? Example.
    
9. How to retry failed test cases using Java + TestNG.
    
10. What is InterruptedException and how to handle it in thread sleep?
    
11. How to handle stale element exception dynamically.
    
12. How to handle NoSuchFrameException.
    
13. How to handle ElementClickInterceptedException.
    
14. How to handle Javascript errors in Selenium.
    
15. How to handle multiple exceptions in single try-catch.
    
16. Difference between throw and rethrow.
    
17. Difference between Exception, RuntimeException, and Throwable.
    
18. How to capture stack trace in Selenium logs.
    
19. How to handle alert not present exception.
    
20. How to implement retry logic with screenshot capture on failure.
    

---

## **4Ô∏è‚É£ Strings & Collections (35 Qs)**

1. Difference between String, StringBuffer, StringBuilder.
    
2. How to split a string in Java.
    
3. How to remove leading/trailing spaces.
    
4. How to reverse a string.
    
5. How to compare strings ignoring case.
    
6. How to extract numeric values from text (e.g., price).
    
7. How to convert List&lt;WebElement&gt; to List&lt;String&gt;.
    
8. How to iterate List&lt;WebElements&gt;.
    
9. Difference between List, Set, Map.
    
10. HashMap vs Hashtable.
    
11. ConcurrentHashMap use case in parallel execution.
    
12. Difference between HashSet and TreeSet.
    
13. How to remove duplicates from List.
    
14. How to sort List of WebElements alphabetically.
    
15. Difference between Iterator and ListIterator.
    
16. Difference between fail-fast and fail-safe iterators.
    
17. How to filter elements using Stream API.
    
18. How to map WebElements to attribute values.
    
19. Difference between keySet(), entrySet(), values() in Map.
    
20. How to search an element in HashMap.
    
21. How to handle dynamic test data using collections.
    
22. How to store test data in Map for key-value lookup.
    
23. How to merge two Maps.
    
24. How to count duplicate elements in List.
    
25. How to find max/min value in List of integers.
    
26. Difference between Array and ArrayList.
    
27. How to convert Array to ArrayList.
    
28. How to convert ArrayList to Array.
    
29. Difference between LinkedList and ArrayList.
    
30. Difference between Stack and Queue.
    
31. How to implement Queue in Selenium waits.
    
32. How to use PriorityQueue in framework.
    
33. Difference between Deque and Queue.
    
34. How to use HashMap to store element locator dynamically.
    
35. How to use Streams for filtering and sorting elements.
    

---

## **5Ô∏è‚É£ File Handling & Data-Driven Testing (25 Qs)**

1. How to read/write from property files.
    
2. How to read Excel using Apache POI.
    
3. How to read JSON test data.
    
4. How to write logs to file.
    
5. How to capture screenshots.
    
6. How to store screenshots in date-wise folder.
    
7. How to upload a file using sendKeys.
    
8. How to verify downloaded file.
    
9. How to read multiple rows from Excel.
    
10. Difference between FileInputStream and FileReader.
    
11. Difference between BufferedReader and Scanner.
    
12. How to read environment-specific properties dynamically.
    
13. How to handle CSV files in Java.
    
14. How to convert JSON array to List&lt;String&gt;.
    
15. How to use try-with-resources for file handling.
    
16. How to read config dynamically for multiple environments.
    
17. How to create logs using Log4j in framework.
    
18. Difference between synchronous and asynchronous file writes.
    
19. How to handle Excel formulas in POI.
    
20. How to validate file existence before upload.
    
21. How to append logs instead of overwrite.
    
22. How to read multiple sheets in Excel.
    
23. How to write test results in Excel dynamically.
    
24. How to read binary files in Java.
    
25. How to validate JSON response structure from API.
    

---

## **6Ô∏è‚É£ Multithreading & Parallel Execution (25 Qs)**

1. What is multi-threading?
    
2. How does TestNG use multi-threading.
    
3. Difference between parallel and sequential execution.
    
4. How to make WebDriver thread-safe using ThreadLocal.
    
5. Difference between synchronized block and method.
    
6. How to handle shared resources in parallel tests.
    
7. How to implement thread-safe singleton driver.
    
8. Difference between Runnable and Thread class.
    
9. Difference between yield(), sleep(), join().
    
10. Difference between wait() and sleep().
    
11. How to run tests in parallel in TestNG.
    
12. How to implement parallel browser execution.
    
13. How to handle data collisions in multi-threaded tests.
    
14. Difference between volatile and ThreadLocal.
    
15. Difference between AtomicInteger and Integer.
    
16. How to handle logging in parallel tests.
    
17. How to handle dynamic reports in parallel execution.
    
18. Difference between concurrency and parallelism.
    
19. How to synchronize methods in utility classes.
    
20. How to handle DB connections in parallel tests.
    
21. Difference between CountDownLatch and CyclicBarrier.
    
22. Difference between ExecutorService and ThreadPool.
    
23. How to terminate threads gracefully.
    
24. How to handle InterruptedException.
    
25. How to implement retry for flaky tests in parallel execution.
    

---

## **7Ô∏è‚É£ Real-World Framework Design & Scenario Questions (50 Qs)**

1. How to implement Singleton WebDriver class.
    
2. How to implement BasePage and ChildPage in POM.
    
3. How to implement Utility class for reusable methods.
    
4. How to implement RetryAnalyzer in TestNG.
    
5. How to capture logs and screenshots on failure.
    
6. How to handle dynamic locators.
    
7. How to handle stale elements dynamically.
    
8. How to select value from dynamic dropdown.
    
9. How to handle multiple windows.
    
10. How to handle alerts and popups.
    
11. How to handle frames and iframes.
    
12. How to verify table contents dynamically.
    
13. How to scroll to element using JavaScriptExecutor.
    
14. How to perform mouse hover and drag-drop.
    
15. How to implement data-driven testing from Excel/JSON.
    
16. How to validate API response on UI.
    
17. How to implement custom wait utilities.
    
18. How to handle checkboxes and radio buttons dynamically.
    
19. How to verify broken links on a page.
    
20. How to run parallel browser tests (Chrome + Firefox).
    
21. How to integrate Selenium with Maven.
    
22. How to generate TestNG/Extent reports dynamically.
    
23. How to implement IRetryAnalyzer for flaky tests.
    
24. How to implement PageFactory in POM.
    
25. How to handle dynamic tables with sorting/filtering.
    
26. How to handle shadow DOM elements.
    
27. How to validate UI elements against DB values.
    
28. How to validate UI elements against API values.
    
29. How to implement BaseTest with setup and teardown methods.
    
30. How to implement reusable wait methods.
    
31. How to verify dynamic error messages.
    
32. How to handle hidden elements using JSExecutor.
    
33. How to implement cross-browser testing using WebDriverFactory.
    
34. How to implement thread-safe reporting.
    
35. How to implement parallel execution with ITestListener.
    
36. How to validate dynamic charts on UI.
    
37. How to validate dynamic pagination.
    
38. How to validate tooltip messages.
    
39. How to handle auto-suggest dropdowns.
    
40. How to implement soft assertions in framework.
    
41. How to integrate Selenium with Rest-Assured.
    
42. How to validate API response in UI automation.
    
43. How to handle SSL certificate warnings.
    
44. How to validate dynamic date pickers.
    
45. How to handle dynamic popups in framework.
    
46. How to implement reusable dropdown selection.
    
47. How to implement fluent wait for dynamic elements.
    
48. How to implement custom ExpectedConditions.
    
49. How to capture dynamic screenshots based on test name.
    
50. How to implement environment-specific test configuration.
    

---

## **8Ô∏è‚É£ Java 8 Features in Automation (25 Qs)**

1. Lambda expressions ‚Äî usage in filtering elements.
    
2. Functional interfaces ‚Äî example in utilities.
    
3. Stream API ‚Äî filter, map, collect.
    
4. Map WebElements to Strings using Stream.
    
5. Sort WebElements using Stream API.
    
6. Parallel Stream vs Sequential Stream.
    
7. Optional class ‚Äî avoid NullPointerException.
    
8. Method references ‚Äî `WebElement::getText`.
    
9. Default methods in interface.
    
10. Static methods in interface.
    
11. How to use Streams with Maps.
    
12. Filter Map entries using Stream.
    
13. Count elements matching criteria using Stream.
    
14. Find first element using Stream.
    
15. Sum values from list using Stream.
    
16. Max/Min using Stream.
    
17. Distinct values using Stream.
    
18. Grouping elements using Stream.
    
19. Joining strings using Stream.
    
20. Limit and skip in Stream.
    
21. AnyMatch/AllMatch/NoneMatch usage.
    
22. Reduce method in Stream.
    
23. How to handle null in Stream using Optional.
    
24. How to apply Stream API in reports.
    
25. How to use Stream API in API response validation.
    

---

## **9Ô∏è‚É£ Core Java + Selenium Scenarios (50 Qs)**

1. Dynamic ID handling.
    
2. StaleElementReferenceException.
    
3. ElementNotInteractableException.
    
4. TimeoutException scenario.
    
5. Handling multiple windows.
    
6. Handling frames and iframes.
    
7. Handling alerts.
    
8. File upload/download.
    
9. Broken links validation.
    
10. Dynamic dropdown selection.
    
11. Scroll to element using JSExecutor.
    
12. Hover actions using Actions class.
    
13. Drag and drop scenario.
    
14. Capturing screenshots on failure.
    
15. Implicit vs Explicit vs Fluent waits.
    
16. Handling auto-suggest dropdown.
    
17. Dynamic table verification.
    
18. Pagination verification.
    
19. Tooltip validation.
    
20. Chart validation.
    
21. Handling shadow DOM elements.
    
22. Cross-browser execution scenario.
    
23. Parallel execution scenario.
    
24. Flaky test retry scenario.
    
25. Thread-safe WebDriver scenario.
    
26. Data-driven login scenario.
    
27. API response validation scenario.
    
28. Dynamic error message validation.
    
29. Hidden element handling scenario.
    
30. Soft assertion scenario.
    
31. JavaScriptExecutor click scenario.
    
32. Handling dynamic modals.
    
33. Environment-specific config handling.
    
34. Validating multiple elements text dynamically.
    
35. Reading dynamic Excel/JSON for test data.
    
36. Synchronization issue scenario.
    
37. Handling InterruptedException.
    
38. Handling dynamic wait polling interval.
    
39. List&lt;WebElement&gt; filtering scenario.
    
40. Verifying multiple links dynamically.
    
41. Lambda expression scenario in Selenium.
    
42. Stream API scenario for filtering elements.
    
43. Optional usage scenario.
    
44. Map test data validation scenario.
    
45. Collection sorting scenario.
    
46. Collection duplicate removal scenario.
    
47. Dynamic screenshot naming scenario.
    
48. Retry mechanism scenario in TestNG.
    
49. Logging scenario using Log4j.
    
50. Parallel report generation scenario.
    

---

**‚úÖ Total Questions:** 300+ (all Java core + automation-related + scenarios)