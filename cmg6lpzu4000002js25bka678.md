---
title: "TypeScript"
datePublished: Tue Sep 30 2025 13:36:49 GMT+0000 (Coordinated Universal Time)
cuid: cmg6lpzu4000002js25bka678
slug: typescript
tags: codewithnini

---

## TypeScript

## 📘 Introduction to TypeScript

---

## In below from this line (Lets study TypeScript………………………………) we start the basics.

## 🔹 1. What is TypeScript?

* **TypeScript (TS)** is a **superset of JavaScript** created by Microsoft.
    
* Adds **static typing** and modern features to JavaScript.
    
* Code is written in `.ts` files and then **compiled (transpiled)** into plain JavaScript (`.js`) which runs in browsers or Node.js.
    

✅ In short: **JavaScript + Type Safety + Modern Features = TypeScript**

![](https://www.typescripttutorial.net/wp-content/uploads/2020/05/what-is-typescript-compiler.png align="left")

---

## 🔹 2. Why Use TypeScript ?

**The main goals of TypeScript are:**

* Catches errors **at compile time** instead of runtime.
    
* Helps with **autocompletion & IntelliSense** in editors.
    
* Makes **Page Object Models (POM)** more maintainable.
    
* Useful for **scalable frameworks** (many test cases, multiple testers).
    

Example:

```java
let age: number = "25"; // ❌ Error in TypeScript
let age: number = 25;   // ✅ Correct
```

---

## 🔹 3. TypeScript vs JavaScript

| Feature | JavaScript (JS) | TypeScript (TS) |
| --- | --- | --- |
| Typing | Dynamic | Static + Dynamic |
| File extension | `.js` | `.ts` |
| Error checking | Runtime | Compile time |
| IDE support | Limited | Excellent (hints, IntelliSense) |
| Compilation required | ❌ No | ✅ Yes (to JS) |

---

## 🔹 4. TypeScript Workflow

1. Install TypeScript:
    
    ```java
    npm install -g typescript
    ```
    
2. Compile `.ts` to `.js`:
    
    ```java
    tsc file.ts
    ```
    
3. Run JavaScript file with Node.js:
    
    ```java
    node file.js
    ```
    

---

## 🔹 5. Key Features of TypeScript

### ✅ Strong Typing

```java
let user: string = "Nini";
let count: number = 10;
let isLoggedIn: boolean = true;
```

### ✅ Interfaces

Useful for describing object structure.

```java
interface User {
  username: string;
  password: string;
}
const admin: User = { username: "admin", password: "12345" };
```

### ✅ Classes & OOP

Supports **Object-Oriented Programming** (very useful in Playwright POM).

```java
class LoginPage {
  constructor(private page: Page) {}
  async login(user: string, pass: string) {
    await this.page.fill("#username", user);
    await this.page.fill("#password", pass);
    await this.page.click("#submit");
  }
}
```

### ✅ Async/Await

First-class support for handling Promises.

```java
async function run() {
  await page.goto("https://example.com");
}
```

### ✅ Modules

Organize code across files.

```java
// loginPage.ts
export class LoginPage { ... }

// test.ts
import { LoginPage } from './loginPage';
```

---

## 🔹 6. TypeScript in Playwright

Playwright is written in TypeScript itself ✅, so when you use TS:

* Better IntelliSense for locators & methods
    
* Autocomplete for [`page.click`](http://page.click), `page.goto`, etc.
    
* Easy error detection before running tests
    

Example:

```java
import { test, expect } from '@playwright/test';

test('basic test', async ({ page }) => {
  await page.goto('https://example.com');
  await expect(page).toHaveTitle(/Example/);
});
```

---

## 🔹 7. Advantages of Using TypeScript in Automation

* ✅ **Scalability** → Large frameworks are easier to manage.
    
* ✅ **Code readability** → Clearer structure with types, interfaces.
    
* ✅ **IDE support** → Faster coding with autocompletion.
    
* ✅ **Fewer bugs** → Errors caught before running tests.
    
* ✅ **Reusability** → Easy to build Page Objects and utilities.
    

---

⚡ **Summary:**  
TypeScript is a **typed superset of JavaScript** that makes automation frameworks like Playwright **more reliable, maintainable, and developer-friendly**.

# **Before we learn we need to know the some of concepts**.

# why did Node.js come to the market in the first place? What problem did it solve?

## **The Background Before Node.js**

Before 2009 (when Node.js was introduced by Ryan Dahl), most web development looked like this:

* **JavaScript only ran in browsers** (for UI interactions).
    
* Server-side code was written in other languages like PHP, Java, Ruby, or .NET.
    
* Each client request was handled in a **blocking, multi-threaded** way — meaning each connection consumed a thread on the server.
    

This caused:

* **High memory consumption** with many connections.
    
* Poor scalability for real-time apps (e.g., chat, gaming, streaming).
    

---

## **Why Node.js Came to Market**

### **1\. To Use JavaScript on the Server**

* Until then, JavaScript was only client-side.
    
* Node.js brought **JavaScript to the backend**, enabling full-stack development with a single language.
    

---

### **2\. Non-blocking, Event-Driven Architecture**

* Traditional servers (like Apache with PHP) used **blocking I/O**: one thread waits for tasks (file read, database query) to complete.
    
* Node.js introduced **non-blocking I/O with an event loop**.
    
* This meant:
    
    * One thread can handle thousands of concurrent requests.
        
    * Great for **real-time apps (chat apps, streaming, APIs)**.
        

---

### **3\. High Performance with V8 Engine**

* Built on **Google Chrome's V8 engine**, Node.js executes JavaScript extremely fast.
    
* Compiles JS into machine code.
    

---

### **4\. Scalability and Lightweight**

* Uses **asynchronous callbacks, promises, async/await**.
    
* Runs on a **single-threaded event loop**, consuming fewer resources than multi-threaded servers.
    

---

### **5\. Huge Ecosystem (npm)**

* Node.js brought **npm (Node Package Manager)**, the world’s largest open-source library ecosystem.
    
* Made it easy to install, share, and update packages.
    

---

### **6\. Ideal for Modern Web Apps**

* Real-time chat (WhatsApp Web, Slack)
    
* Streaming services (Netflix, YouTube backend components)
    
* Microservices & APIs
    
* Automation tools (Playwright, Cypress)
    

---

## **In Simple Words**

Node.js came to the market to:

* **Break the wall between frontend and backend** (one language: JavaScript)
    
* **Handle high-concurrency applications efficiently**
    
* **Speed up development with a giant package ecosystem**
    
* **Enable real-time and scalable applications**
    

---

## **Analogy**

Old servers = Waiters who serve one table at a time (blocking).  
Node.js = A smart waiter who takes many orders, delivers them as they’re ready, and never waits idly.

## What is Node Package Manager (npm) is, how it came to exist, and Why it became essential for Node.js and the JavaScript ecosystem.

## **What is npm (Node Package Manager)?**

* **npm** is the default package manager for Node.js.
    
* It allows you to **install, share, manage, and update code packages (libraries, tools, frameworks)**.
    
* It comes bundled with Node.js (no need to install separately).
    

### **What Does npm Do?**

* Installs libraries like Express, React, Playwright, etc.
    
* Manages dependencies in your project via `package.json`.
    
* Allows you to publish your own packages.
    
* Provides access to the **world’s largest open-source library ecosystem**.
    

---

## **How Did npm Come? (The History)**

### **Before npm**

* JavaScript was mostly used in browsers.
    
* Developers relied on manually downloading libraries and linking them with `<script>` tags.
    
* Dependency management was a nightmare:
    
    * No central repository
        
    * Version conflicts (different libraries requiring different versions)
        
    * No standard way to share packages
        

### **The Birth of npm**

* **Created in 2010 by Isaac Z. Schlueter**, shortly after Node.js (2009).
    
* Built to solve:
    
    * **Package sharing** for Node.js
        
    * **Dependency management** in one place
        
    * **Version control** for libraries
        

### **npm's Growth**

* Quickly became the **standard package manager for Node.js**.
    
* Expanded to support frontend tools (React, Angular, Vue, TypeScript, Webpack).
    
* Now used not only in Node.js apps but also for automation, CI/CD, and even Python/.NET integrations.
    

---

## **How npm Works?**

1. You create a project:
    
    ```bash
    npm init -y
    ```
    
    → Creates `package.json` (tracks dependencies and project metadata).
    
2. Install a package:
    
    ```bash
    npm install express
    ```
    
    → Downloads package to `node_modules/` and updates `package.json`.
    
3. Use it in your code:
    
    ```javascript
    const express = require('express');
    ```
    
4. Update or remove packages easily:
    
    ```bash
    npm update
    npm uninstall express
    ```
    
5. Publish your own library:
    
    ```bash
    npm publish
    ```
    

---

## **Why npm is Important ?**

* Makes Node.js scalable and developer-friendly.
    
* Encourages code reuse (no need to rewrite common modules).
    
* Powers tools like Playwright, Selenium WebDriver JS, ESLint, TypeScript, etc.
    
* Became the **largest package ecosystem in the world (2M+ packages)**.
    

---

## **Alternatives to npm ?**

* **Yarn** (Facebook’s alternative, faster installs, better caching).
    
* **pnpm** (space-efficient, symlink-based).
    
* **Bun** (modern, ultra-fast).
    

But npm remains the default and most widely supported.

## **1\. npm Workflow (Step by Step with Diagram)**

Here’s how npm works in a typical Node.js project:

```java
 ┌─────────────────────┐
 │ Install Node.js     │
 │ (npm comes with it) │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Initialize Project  │
 │ npm init -y         │
 │ → creates package.json│
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Install Packages    │
 │ npm install <pkg>   │
 │ → node_modules/     │
 │ → package-lock.json │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Use in Code         │
 │ require()/import    │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Update/Remove       │
 │ npm update / uninstall│
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Share Your Project  │
 │ via package.json    │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Publish Your Package│
 │ npm publish         │
 └─────────────────────┘
```

---

## **2\. Key npm Commands (Automation & Testing Focus)**

### **Project Setup**

* `npm init -y` → Creates a default `package.json`
    
* `npm install` → Installs all dependencies listed in `package.json`
    

### **Installing Tools**

* Playwright:
    
    ```bash
    npm install -D @playwright/test
    npx playwright install
    ```
    
* Selenium WebDriver:
    
    ```bash
    npm install selenium-webdriver
    ```
    
* TypeScript:
    
    ```bash
    npm install -D typescript ts-node @types/node
    ```
    

### **Running Tests**

* Using Playwright:
    
    ```bash
    npx playwright test
    ```
    
* Using Selenium with Node:
    
    ```bash
    node your_test.js
    ```
    

### **Updating Dependencies**

* Update all:
    
    ```bash
    npm update
    ```
    
* Update a specific package:
    
    ```bash
    npm install <package>@latest
    ```
    

### **Other Important Commands**

* `npm list` → View installed packages
    
* `npm outdated` → Check for outdated packages
    
* `npm uninstall <package>` → Remove a package
    
* `npm cache clean --force` → Clear npm cache
    

---

## **3\. npm vs Maven (For Automation Testing)**

You’re already learning **Maven** for Java automation, so here’s a direct comparison:

| **Feature** | **npm (Node.js**) | **Maven (Java)** |
| --- | --- | --- |
| **Language Focus** | JavaScript/TypeScript | Java, Kotlin |
| **Dependency File** | `package.json` | `pom.xml` |
| **Package Repository** | npm registry (2M+ packages) | Maven Central (1M+ packages) |
| **Execution** | `npm run`, `npx` | `mvn clean install`, `mvn test` |
| **Build System** | No default build (Webpack, Rollup, etc.) | Built-in build lifecycle |
| **Test Integration** | Playwright, Jest, Mocha, Cypress | TestNG, JUnit, Selenium |
| **Usage in QA** | Web/API automation (Playwright, Cypress) | Web/API automation (Selenium, REST-Assured) |
| **Installation** | `npm install` (fast, lightweight) | `mvn install` (slower, XML heavy) |

### **When to Use npm in Automation?**

* Playwright, Cypress, Puppeteer automation
    
* API testing with Supertest or Axios
    
* TypeScript-based frameworks
    

### **When to Use Maven in Automation?**

* Selenium + Java/TestNG/JUnit projects
    
* RestAssured, Cucumber with Java
    
* Enterprise CI/CD pipelines using Java stack.
    
    # **Before leaening TypeScript or Playwright just UnderStand the below Topics.**
    

# 📘 JavaScript Modules

---

## 1️⃣ What Are Modules?

* A **module** is a file in JavaScript that **exports** variables, functions, or classes so they can be **imported** in another file.
    
* Modules help **organize code**, **avoid polluting global scope**, and **increase maintainability**.
    

**Example:**

```bash
// mathUtils.js
export function add(a, b) {
  return a + b;
}
export const PI = 3.14;

// main.js
import { add, PI } from './mathUtils.js';
console.log(add(5, 3)); // 8
console.log(PI);        // 3.14
```

✅ Key points:

* Use `export` to make variables/functions/classes available outside the module.
    
* Use `import` to access exported content in another module.
    

---

## 2️⃣ Types of Exports

### Named Export

```bash
// utils.js
export function greet(name) { return `Hello ${name}`; }
export const version = "1.0";

// app.js
import { greet, version } from './utils.js';
console.log(greet("Nini")); // Hello Nini
```

### Default Export

* A module can have **one default export**, which can be imported with any name.
    

```bash
// logger.js
export default function log(message) { console.log(message); }

// app.js
import logFunc from './logger.js';
logFunc("Test started"); // Test started
```

---

## 3️⃣ Dynamic Import

* **Dynamic import** allows importing a module **at runtime**, not at the start.
    
* Returns a **Promise**, useful for **lazy loading modules**.
    

```bash
async function run() {
  const math = await import('./mathUtils.js');
  console.log(math.add(2, 3)); // 5
}
run();
```

✅ Use cases:

* Load modules **only when needed** (performance optimization).
    
* Conditional module loading:
    

```bash
if (condition) {
  const module = await import('./featureA.js');
  module.runFeature();
}
```

---

## 4️⃣ Top-Level Await in Modules

* **Top-level await** allows using `await` **outside of async functions** at the top of a module.
    
* Only works **inside ES modules** (files with `.js` using `type: "module"` or `.mjs` files).
    

```bash
// dataLoader.js
const response = await fetch('https://api.example.com/data');
const data = await response.json();
console.log(data);
```

✅ Advantages:

* Makes async initialization simpler.
    
* Useful for loading configuration, test data, or setup before running automation tests.
    

---

## 5️⃣ Using Modules in Node.js / Playwright

* In **Node.js / Playwright**, enable ES modules by:
    
    * Using `"type": "module"` in `package.json`
        
    * Or naming files `.mjs`
        

```bash
// package.json
{
  "name": "playwright-project",
  "type": "module"
}
```

* Example in Playwright:
    

```bash
// pageObjects/loginPage.js
export class LoginPage {
  constructor(page) { this.page = page; }
  async login(user, pass) {
    await this.page.fill('#username', user);
    await this.page.fill('#password', pass);
    await this.page.click('button[type=submit]');
  }
}

// tests/login.test.js
import { test } from '@playwright/test';
import { LoginPage } from '../pageObjects/loginPage.js';

test('login test', async ({ page }) => {
  const login = new LoginPage(page);
  await login.login('admin', '12345');
});
```

---

✅ **Summary:**

* **Modules**: Orga📘 JavaScript Modules
    
    ---
    
    ## 1️⃣ What Are Modules?
    
    * A **module** is a file in JavaScript that **exports** variables, functions, or classes so they can be **imported** in another file.
        
    * Modules help **organize code**, **avoid polluting global scope**, and **increase maintainability**.
        
    
    **Example:**
    
    ```bash
    // mathUtils.js
    export function add(a, b) {
      return a + b;
    }
    export const PI = 3.14;
    
    // main.js
    import { add, PI } from './mathUtils.js';
    console.log(add(5, 3)); // 8
    console.log(PI);        // 3.14
    ```
    
    ✅ Key points:
    
    * Use `export` to make variables/functions/classes available outside the module.
        
    * Use `import` to access exported content in another module.
        
    
    ---
    
    ## 2️⃣ Types of Exports
    
    ### Named Export
    
    ```bash
    // utils.js
    export function greet(name) { return `Hello ${name}`; }
    export const version = "1.0";
    
    // app.js
    import { greet, version } from './utils.js';
    console.log(greet("Nini")); // Hello Nini
    ```
    
    ### Default Export
    
    * A module can have **one default export**, which can be imported with any name.
        
    
    ```bash
    // logger.js
    export default function log(message) { console.log(message); }
    
    // app.js
    import logFunc from './logger.js';
    logFunc("Test started"); // Test started
    ```
    
    ---
    
    ## 3️⃣ Dynamic Import
    
    * **Dynamic import** allows importing a module **at runtime**, not at the start.
        
    * Returns a **Promise**, useful for **lazy loading modules**.
        
    
    ```bash
    async function run() {
      const math = await import('./mathUtils.js');
      console.log(math.add(2, 3)); // 5
    }
    run();
    ```
    
    ✅ Use cases:
    
    * Load modules **only when needed** (performance optimization).
        
    * Conditional module loading:
        
    
    ```bash
    if (condition) {
      const module = await import('./featureA.js');
      module.runFeature();
    }
    ```
    
    ---
    
    ## 4️⃣ Top-Level Await in Modules
    
    * **Top-level await** allows using `await` **outside of async functions** at the top of a module.
        
    * Only works **inside ES modules** (files with `.js` using `type: "module"` or `.mjs` files).
        
    
    ```bash
    // dataLoader.js
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
    ```
    
    ✅ Advantages:
    
    * Makes async initialization simpler.
        
    * Useful for loading configuration, test data, or setup before running automation tests.
        
    
    ---
    
    ## 5️⃣ Using Modules in Node.js / Playwright
    
    * In **Node.js / Playwright**, enable ES modules by:
        
        * Using `"type": "module"` in `package.json`
            
        * Or naming files `.mjs`
            
    
    ```bash
    // package.json
    {
      "name": "playwright-project",
      "type": "module"
    }
    ```
    
    * Example in Playwright:
        
    
    ```bash
    // pageObjects/loginPage.js
    export class LoginPage {
      constructor(page) { this.page = page; }
      async login(user, pass) {
        await this.page.fill('#username', user);
        await this.page.fill('#password', pass);
        await this.page.click('button[type=submit]');
      }
    }
    
    // tests/login.test.js
    import { test } from '@playwright/test';
    import { LoginPage } from '../pageObjects/loginPage.js';
    
    test('login test', async ({ page }) => {
      const login = new LoginPage(page);
      await login.login('admin', '12345');
    });
    ```
    
    ---
    
    ✅ **Summary:**
    
    * **Modules**: Organize and export code.
        
    * **Dynamic Import**: Load modules at runtime.
        
    * **Top-level Await**: Use `await` outside async functions at the module top level.
        
    * **Playwright Use**: Modularize POMs, utilities, and test scripts using ES modules.nize and export code.
        
* **Dynamic Import**: Load modules at runtime.
    
* **Top-level Await**: Use `await` outside async functions at the module top level.
    
* **Playwright Use**: Modularize POMs, utilities, and test scripts using ES modules.
    

✅ Let’s compare **JavaScript/TypeScript modules, dynamic import, and top-level await** with **Java equivalents** so it’s easy to relate.

---

## 📊 Comparison: JS Modules vs Java

| Feature | JavaScript / TypeScript | Java Equivalent | Example |
| --- | --- | --- | --- |
| **Modules / Imports** | `export` / `import` | `public class` + `import package.Class` | JS: |
| `js export class Login {} import { Login } from './Login.js';` |  |  |  |
| Java: |  |  |  |
| `java package pages; public class Login {} import pages.Login;` |  |  |  |
| **Named Export / Import** | Multiple exports per file | Multiple public classes or methods in packages | JS: |
| `export function add(){} export const PI=3.14;` |  |  |  |
| Java: |  |  |  |
| `public class MathUtils { public static final double PI=3.14; public static int add(int a,int b){return a+b;} }` |  |  |  |
| **Default Export** | One default export per module | Class itself as main exposed API | JS: |
| `export default class Logger{} import Logger from './Logger.js';` |  |  |  |
| Java: |  |  |  |
| `public class Logger {} // import pages.Logger;` |  |  |  |
| **Dynamic Import** | `import()` at runtime, returns Promise | Reflection or Class.forName() | JS: |
| `const module = await import('./math.js');` |  |  |  |
| Java: |  |  |  |
| `Class<?> clazz = Class.forName("pages.Login"); Object obj = clazz.getDeclaredConstructor().newInstance();` |  |  |  |
| **Top-level Await** | Can use `await` outside async function in module | Java doesn’t allow await at top level; must use `main` or another async context | JS: |
| `const data = await fetch(url);` |  |  |  |
| Java: |  |  |  |
| `CompletableFuture<String> data = httpClient.sendAsync(request, BodyHandlers.ofString()); data.thenAccept(System.out::println);` |  |  |  |

---

### 🔹 Key Observations:

1. **Modules:** Both organize code; JS uses file-based exports, Java uses packages & public classes.
    
2. **Dynamic import:** JS supports runtime loading natively; Java requires reflection (`Class.forName`).
    
3. **Top-level await:** JS modules allow simpler async initialization; Java always needs an **async context** (like `CompletableFuture` or threads).
    

---

### ⚡ Example: Playwright-like Page Object

**JavaScript / TypeScript (Module + POM + Await):**

```javascript
// loginPage.js
export class LoginPage {
  constructor(page) { this.page = page; }
  async login(user, pass) {
    await this.page.fill('#username', user);
    await this.page.fill('#password', pass);
    await this.page.click('#submit');
  }
}

// test.js
import { LoginPage } from './loginPage.js';
const login = new LoginPage(page);
await login.login('admin', '12345');
```

**Java (Selenium Page Object):**

```java
// LoginPage.java
package pages;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.By;

public class LoginPage {
    WebDriver driver;
    public LoginPage(WebDriver driver) { this.driver = driver; }
    public void login(String user, String pass) {
        driver.findElement(By.id("username")).sendKeys(user);
        driver.findElement(By.id("password")).sendKeys(pass);
        driver.findElement(By.id("submit")).click();
    }
}

// LoginTest.java
import pages.LoginPage;
LoginPage login = new LoginPage(driver);
login.login("admin","12345");
```

✅ As you can see:

* **Module import/export** in JS ≈ **package + import** in Java.
    
* **Async / Await** in JS ≈ **WebDriver waits / threads / CompletableFuture** in Java.
    
* Dynamic import in JS ≈ Reflection in Java.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759252853515/0fdc346d-9cfa-41f0-ae49-f10936a0ee04.png align="center")

## Statically and Dynamically Type Language

## **Typing Concepts**

| Feature | Statically Typed Language | Dynamically Typed Language |
| --- | --- | --- |
| **Definition** | Variable types are known at **compile time**. | Variable types are determined at **runtime**. |
| **Type Checking** | Done during compilation. | Done during execution. |
| **Error Detection** | Many type-related errors are caught **before running the code**. | Type errors appear only when the code executes. |
| **Flexibility** | Less flexible, more strict. | More flexible, allows implicit type changes. |
| **Examples** | Java, TypeScript | JavaScript, Python |

---

## **2\. Comparison Using JS, TS, and Java**

### **JavaScript (Dynamically Typed)**

```javascript
let x = 10;    // x is number now
x = "Hello";   // x is now string, no error
console.log(x); // Output: Hello
```

* JS doesn’t enforce types.
    
* A variable can change its type at any time.
    
* Errors like adding a string to a number are only found at runtime.
    

---

### **TypeScript (Statically Typed)**

```javascript
let x: number = 10;
x = "Hello"; // ❌ Error: Type 'string' is not assignable to type 'number'
```

* TS is statically typed (optional, but recommended).
    
* Types are checked at **compile time**.
    
* Helps catch errors early before running the code.
    
* You can also use `any` type for dynamic behavior:
    

```javascript
let y: any = 10;
y = "Hello"; // ✅ No error
```

---

### **Java (Statically Typed)**

```javascript
int x = 10;
x = "Hello"; // ❌ Compile-time error
```

* Java is strictly statically typed.
    
* You must declare the type of every variable.
    
* Errors are caught during compilation.
    

---

## **3\. Key Differences Between JS, TS, and Java**

| Feature | JavaScript | TypeScript | Java |
| --- | --- | --- | --- |
| Typing | Dynamic | Static (optional) | Static |
| Compilation | Interpreted | Compiled to JS | Compiled to bytecode |
| Type Safety | Low | High | Very High |
| Variable Reassignment | Any type | Must follow declared type | Must follow declared type |
| Error Detection | Runtime | Compile-time | Compile-time |
| Popular Use | Web | Web, Large-scale apps | Enterprise, Backend, Android |

---

### **Summary**

* **JS:** Flexible but prone to runtime errors.
    
* **TS:** Adds static typing to JS → safer, easier to maintain.
    
* **Java:** Fully statically typed → very strict, robust for large apps.
    

---

If you want, I can also make a **diagram showing JS vs TS vs Java type checking** in a simple visual way that’s easy to remember.

Do you want me to do that?

##### You said:

ok

###### ChatGPT said:

Perfect! Here's a simple visual diagram comparing **JavaScript, TypeScript, and Java** in terms of typing and error detection:

---

### **Type System Comparison Diagram**

```javascript
             +-------------------------+
             |      JavaScript         |
             |  Dynamically Typed      |
             |  Type checked at runtime|
             |  Flexible, but risky   |
             +-------------------------+
                        |
                        v
             +-------------------------+
             |      TypeScript         |
             |  Statically Typed       |
             |  Type checked at compile|
             |  Can catch errors early |
             |  Safer than JS          |
             +-------------------------+
                        |
                        v
             +-------------------------+
             |         Java            |
             |  Statically Typed       |
             |  Strict compile-time    |
             |  Very robust & safe     |
             +-------------------------+
```

---

### **Quick Example Table**

| Language | Variable Declaration | Type Checking | Example Error |
| --- | --- | --- | --- |
| JavaScript | `let x = 10;` | Runtime | `x = "Hello"; // ok at compile, fails at runtime if logic depends on number` |
| TypeScript | `let x: number = 10;` | Compile-time | `x = "Hello"; // ❌ Error at compile time` |
| Java | `int x = 10;` | Compile-time | `x = "Hello"; // ❌ Error at compile time` |

---

✅ **Takeaway:**

* JS = flexible, runtime errors
    
* TS = JS + static type safety
    
* Java = strict static typing
    

# Lets study TypeScript………………………………

## Coomads need to know..

## **📘 Node.js Commands**

| Command | Description |
| --- | --- |
| `node -v` | Check Node.js version |
| `npm -v` | Check npm version |
| `npm init` | Initialize a new project (interactive) |
| `npm init -y` | Initialize a new project with default settings |
| `npm install <package>` | Install package locally |
| `npm install -g <package>` | Install package globally |
| `npm install --save <package>` | Add package to dependencies |
| `npm install --save-dev <package>` | Add package to devDependencies |
| `npm uninstall <package>` | Remove a package |
| `npm update <package>` | Update a package |
| `node app.js` | Run a JS file |
| `nodemon app.js` | Run with auto-reload (requires nodemon) |
| `npm start` | Run start script from package.json |
| `npm run <script>` | Run custom script from package.json |
| `npm list -g --depth=0` | List global packages |
| `npm outdated` | Check outdated packages |
| `node` | Start Node.js REPL (interactive console) |
| `node --inspect app.js` | Debug Node.js file using Chrome DevTools |
| `node --trace-warnings app.js` | Show runtime warnings |

---

## **📘 TypeScript Commands**

| Command | Description |
| --- | --- |
| `npm install -g typescript` | Install TypeScript globally |
| `tsc -v` | Check TypeScript version |
| `tsc --init` | Initialize a TypeScript project (`tsconfig.json`) |
| `tsc app.ts` | Compile a single TypeScript file to JavaScript |
| `tsc` | Compile project using `tsconfig.json` |
| `tsc -w` | Watch mode – automatically compile on file changes |
| `tsc app.ts --target ES6` | Compile TS file targeting ES6 JS |
| `tsc app.ts --outDir ./dist` | Set output directory for compiled JS |
| `tsc app.ts --module commonjs` | Set module system |
| `ts-node app.ts` | Run TypeScript file directly without compiling (requires `ts-node`) |
| `tsc --listFiles` | List all files compiled by TypeScript |
| `tsc --diagnostics` | Show compilation statistics |
| `tsc --init --strict` | Create `tsconfig.json` with strict mode enabled |
| `tslint -c tslint.json 'src/**/*.ts'` | Lint TypeScript files (requires `tslint`) |
| `prettier --write "src/**/*.ts"` | Format TypeScript files (requires `prettier`) |

---

✅ **Tip:**

* **Node.js commands** are mostly for runtime, package management, and debugging.
    
* **TypeScript commands** focus on compilation, type checking, and project configuration.
    

## **1\. Introduction to TypeScript**

* TypeScript is a **superset of JavaScript** that adds **static types**.
    
* Compiles to plain JavaScript: `tsc filename.ts`
    
* Advantages:
    
    * Early error detection
        
    * Better IDE support (autocomplete, intellisense)
        
    * Large-scale app maintainability
        

---

## **2\. Installing TypeScript**

```javascript
# Install globally
npm install -g typescript

# Check version
tsc -v

# Compile TypeScript to JavaScript
tsc app.ts
```

* Run JS file: `node app.js`
    

---

## **3\. Basic Types**

| Type | Example |
| --- | --- |
| `boolean` | `let isDone: boolean = true;` |
| `number` | `let count: number = 10;` |
| `string` | `let name: string = "Nini";` |
| `array` | `let arr: number[] = [1,2,3];` |
| `tuple` | `let tuple: [string, number] = ["hello", 10];` |
| `enum` | `enum Color {Red, Green, Blue}; let c: Color =` [`Color.Green`](http://Color.Green)`;` |
| `any` | `let value: any = 5; value = "hello";` |
| `void` | `function log(): void { console.log("hi"); }` |
| `null/undefined` | `let u: undefined = undefined; let n: null = null;` |
| `never` | `function error(): never { throw new Error("error"); }` |

---

## **4\. Variables and Constants**

```javascript
let x: number = 10;  // mutable
const y: string = "Hello"; // immutable
```

* `let` → block-scoped variable
    
* `const` → block-scoped constant
    
* `var` → function-scoped (avoid in modern TS/JS)
    

---

## **5\. Functions**

```javascript
// Named function with typed params and return
function add(a: number, b: number): number {
    return a + b;
}

// Optional parameter
function greet(name?: string): string {
    return `Hello ${name || "Guest"}`;
}

// Default parameter
function multiply(a: number, b: number = 2): number {
    return a * b;
}

// Rest parameter
function sum(...numbers: number[]): number {
    return numbers.reduce((a, b) => a + b, 0);
}
```

---

## **6\. Interfaces**

* Define **object shapes** and enforce structure.
    

```javascript
interface Person {
    name: string;
    age: number;
    greet(): void;
}

let user: Person = {
    name: "Nini",
    age: 25,
    greet() { console.log("Hello!"); }
};
```

* Optional properties: `age?: number`
    
* Readonly properties: `readonly id: number`
    

---

## **7\. Classes & OOP**

```javascript
class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    move(distance: number = 0) {
        console.log(`${this.name} moved ${distance}m`);
    }
}

class Dog extends Animal {
    bark() { console.log("Woof!"); }
}

let dog = new Dog("Buddy");
dog.bark();
dog.move(10);
```

* **Access Modifiers**: `public` (default), `private`, `protected`
    
* **Readonly properties**: cannot be modified outside constructor
    
* **Static properties/methods**: belong to class, not instance
    

---

## **8\. Generics**

```javascript
function identity<T>(arg: T): T {
    return arg;
}

let output = identity<string>("Hello");
let num = identity<number>(42);

// Generic interface
interface GenericIdentity<T> {
    (arg: T): T;
}
```

* Generics allow **type-safe reusable components**.
    

---

## **9\. Type Aliases & Union Types**

```javascript
type ID = string | number;

let userId: ID;
userId = 123;
userId = "abc";

type Point = { x: number; y: number };
let p: Point = { x: 10, y: 20 };
```

* **Union types:** `string | number` → variable can hold multiple types
    
* **Intersection types:** `type AB = A & B` → merge types
    

---

## **10\. Type Assertions & Casting**

```javascript
let someValue: any = "Hello TS";
let strLength: number = (someValue as string).length;

// alternative syntax
let strLength2: number = (<string>someValue).length;
```

* Tells compiler: “trust me, this variable is of this type”
    

---

## **11\. Modules & Namespaces**

```javascript
// export.ts
export const PI = 3.14;
export function calculateArea(radius: number) { return PI * radius * radius; }

// import.ts
import { PI, calculateArea } from "./export";
console.log(calculateArea(5));
```

* **ES Modules** supported: `export` / `import`
    
* Use `namespace` for grouping in global scope (less common)
    

---

## **12\. Advanced Types**

| Feature | Example |
| --- | --- |
| Literal Types | \`let direction: "left" |
| Type Guards | `if (typeof value === "string") { ... }` |
| keyof | `type Keys = keyof Person;` |
| Conditional Types | `type Message<T> = T extends string ? string : number;` |
| Mapped Types | `type Readonly<T> = { readonly [K in keyof T]: T[K] };` |

---

## **13\. Decorators (Experimental)**

* Decorators add metadata or modify class behavior
    

```javascript
function Log(target: any, propertyKey: string) {
    console.log(`${propertyKey} decorated`);
}

class MyClass {
    @Log
    myMethod() { console.log("Hello"); }
}
```

* Enable in `tsconfig.json`:
    

```javascript
"experimentalDecorators": true
```

---

## **14\. Utility Types (Built-in)**

| Utility | Description |
| --- | --- |
| `Partial<T>` | Makes all properties optional |
| `Required<T>` | Makes all properties required |
| `Readonly<T>` | Makes all properties readonly |
| `Pick<T, K>` | Picks specific properties from type |
| `Omit<T, K>` | Omits specific properties from type |

---

## **15\. TypeScript Compiler Options**

Key options in `tsconfig.json`:

```javascript
{
  "target": "ES6",
  "module": "commonjs",
  "strict": true,
  "esModuleInterop": true,
  "outDir": "./dist",
  "rootDir": "./src",
  "sourceMap": true
}
```

* `"strict": true` → enables strict type-checking
    
* `"esModuleInterop": true` → allows default import of CommonJS modules
    

---

## **16\. TypeScript with Node & Browser**

* Node: `tsc` → compile → `node dist/app.js`
    
* Browser: use bundlers (Webpack, Vite) to compile TS → JS
    

---

## ✅ **Summary**

TypeScript is **typed JavaScript** that improves maintainability, reduces runtime errors, and supports modern JS features plus static type safety. Key pillars:

1. Types (`string`, `number`, `boolean`, `any`, `tuple`, `enum`)
    
2. Interfaces & Classes (OOP)
    
3. Generics (reusable components)
    
4. Modules & Namespaces
    
5. Advanced Types (`union`, `intersection`, `conditional`)
    
6. Compiler & Config (`tsconfig.json`)
    

# **01 What is TypeScript**

# **02 TypeScript Setup**

The following tools you need to set up to start with TypeScript:

* **Visual Studio Code or VS Code** – a code editor supporting TypeScript.
    
* **Node.js** – Node.js is the environment in which you will run the TypeScript compiler.
    
* **TypeScript compiler** – a Node.js module that compiles TypeScript into JavaScript.
    

If you use VS Code, you can install the following extension to speed up the development process:

* [Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) – allows you to launch a development local web server with the hot reload feature.
    

## **Install Node.js**

**Install** node.js and open Command Prompt on Windows and type the command `node -v`, it should show the installed version of Node.js.

## **Install TypeScript compiler**

To install the TypeScript compiler, you launch the Terminal on macOS or Linux and Command Prompt on Windows and type the following command:

```bash
// global
npm install -g typescript 
// or
// local (This keeps your project self-contained and avoids version mismatches.
npm install --save-dev typescript 
```

After the installation, you can type the following command to check the current version of the TypeScript **tsc --v**

It should return the version like this: **Version 5.8.3**

## **Install tsx module**

If you want to run TypeScript code directly on Node.js without precompiling, you can use the `tsx` module.

## **Summary**

* A TypeScript compiler compiles the TypeScript into JavaScript.
    
* Use the `tsc` command to compile a TypeScript file to a JavaScript file.
    
* Use the `tsx` module to run TypeScript directly on Node.js without precompiling it to JavaScript.
    

# **03 TypeScript “Hello, Nini!”**

## **TypeScript Hello Nini program in Node.js**

* launch VS Code create a directory as **TypeScript** and inside create another child directoty as **TypeScript\_Tutorial** . and install all as **local (**This keeps the project self-contained and avoids version mismatches).
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759317474112/99f83038-486c-4f8c-9c18-b2b2197ebb84.png align="center")
    
    Inside **TypeScript\_Tutorial** project create a new directory as **HelloNini** and Inside **HelloNini-derectory** create a new TypeScript file called `app.ts`. The extension of a TypeScript file is `.ts`.
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759317867674/677c3615-b682-474b-ade5-d9ff11b5661f.png align="center")
    
    Here i have added another file as **README.md** file to give extra information about the project.
    
* And type the following source code in the `app.ts` file.
    
    ```typescript
    let message: string = 'Hello, Nini!';
    console.log(message);
    ```
    
    Right-Click on directoty and **open in integrated Terminal** to compile the **.ts** file .
    
* type the following command on the Terminal to compile the `tsc app.ts` and click **enter.**
    
* If everything is fine, you’ll see a new file called `app.js` is generated by the TypeScript compiler.
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759318745101/20e10e14-3032-4d05-9141-3ffa25aafde1.png align="center")
    
    To run the `app.js` file in `Node.js`, type following command in same directory `node app.js`.
    

![](https://www.typescripttutorial.net/wp-content/uploads/2020/05/TypeScript-Hello-World-compile-TS-file.png align="left")

If everything is fine, you’ll see a new file called `app.js` is generated by the TypeScript compiler:

![](https://www.typescripttutorial.net/wp-content/uploads/2020/05/TypeScript-Hello-World-Output-file.png align="left")

To run the `app.js` file in `Node.js`, you use the following command:

**OUTPUT:**

```bash
hp@NINI MINGW64 /TypeScript/TypeScript_Tutorial/HelloNini (main)
$ node app.js
Hello, Nini!
```