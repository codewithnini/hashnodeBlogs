---
title: "TypeScript"
datePublished: Tue Sep 30 2025 13:36:49 GMT+0000 (Coordinated Universal Time)
cuid: cmg6lpzu4000002js25bka678
slug: typescript
tags: codewithnini

---

## TypeScript

## 📘 Introduction to TypeScript

---

## 🔹 1. What is TypeScript?

* **TypeScript (TS)** is a **superset of JavaScript** created by Microsoft.
    
* Adds **static typing** and modern features to JavaScript.
    
* Code is written in `.ts` files and then **compiled (transpiled)** into plain JavaScript (`.js`) which runs in browsers or Node.js.
    

✅ In short: **JavaScript + Type Safety + Modern Features = TypeScript**

![](https://www.typescripttutorial.net/wp-content/uploads/2020/05/what-is-typescript-compiler.png align="left")

---

## 🔹 2. Why Use TypeScript ?

**The main goals of TypeScript are:**

* Catches errors **at compile time** instead of runtime.
    
* Helps with **autocompletion & IntelliSense** in editors.
    
* Makes **Page Object Models (POM)** more maintainable.
    
* Useful for **scalable frameworks** (many test cases, multiple testers).
    

Example:

```java
let age: number = "25"; // ❌ Error in TypeScript
let age: number = 25;   // ✅ Correct
```

---

## 🔹 3. TypeScript vs JavaScript

| Feature | JavaScript (JS) | TypeScript (TS) |
| --- | --- | --- |
| Typing | Dynamic | Static + Dynamic |
| File extension | `.js` | `.ts` |
| Error checking | Runtime | Compile time |
| IDE support | Limited | Excellent (hints, IntelliSense) |
| Compilation required | ❌ No | ✅ Yes (to JS) |

---

## 🔹 4. TypeScript Workflow

1. Install TypeScript:
    
    ```java
    npm install -g typescript
    ```
    
2. Compile `.ts` to `.js`:
    
    ```java
    tsc file.ts
    ```
    
3. Run JavaScript file with Node.js:
    
    ```java
    node file.js
    ```
    

---

## 🔹 5. Key Features of TypeScript

### ✅ Strong Typing

```java
let user: string = "Nini";
let count: number = 10;
let isLoggedIn: boolean = true;
```

### ✅ Interfaces

Useful for describing object structure.

```java
interface User {
  username: string;
  password: string;
}
const admin: User = { username: "admin", password: "12345" };
```

### ✅ Classes & OOP

Supports **Object-Oriented Programming** (very useful in Playwright POM).

```java
class LoginPage {
  constructor(private page: Page) {}
  async login(user: string, pass: string) {
    await this.page.fill("#username", user);
    await this.page.fill("#password", pass);
    await this.page.click("#submit");
  }
}
```

### ✅ Async/Await

First-class support for handling Promises.

```java
async function run() {
  await page.goto("https://example.com");
}
```

### ✅ Modules

Organize code across files.

```java
// loginPage.ts
export class LoginPage { ... }

// test.ts
import { LoginPage } from './loginPage';
```

---

## 🔹 6. TypeScript in Playwright

Playwright is written in TypeScript itself ✅, so when you use TS:

* Better IntelliSense for locators & methods
    
* Autocomplete for [`page.click`](http://page.click), `page.goto`, etc.
    
* Easy error detection before running tests
    

Example:

```java
import { test, expect } from '@playwright/test';

test('basic test', async ({ page }) => {
  await page.goto('https://example.com');
  await expect(page).toHaveTitle(/Example/);
});
```

---

## 🔹 7. Advantages of Using TypeScript in Automation

* ✅ **Scalability** → Large frameworks are easier to manage.
    
* ✅ **Code readability** → Clearer structure with types, interfaces.
    
* ✅ **IDE support** → Faster coding with autocompletion.
    
* ✅ **Fewer bugs** → Errors caught before running tests.
    
* ✅ **Reusability** → Easy to build Page Objects and utilities.
    

---

⚡ **Summary:**  
TypeScript is a **typed superset of JavaScript** that makes automation frameworks like Playwright **more reliable, maintainable, and developer-friendly**.

# **Before we learn we need to know the some of concepts**.

# why did Node.js come to the market in the first place? What problem did it solve?

## **The Background Before Node.js**

Before 2009 (when Node.js was introduced by Ryan Dahl), most web development looked like this:

* **JavaScript only ran in browsers** (for UI interactions).
    
* Server-side code was written in other languages like PHP, Java, Ruby, or .NET.
    
* Each client request was handled in a **blocking, multi-threaded** way — meaning each connection consumed a thread on the server.
    

This caused:

* **High memory consumption** with many connections.
    
* Poor scalability for real-time apps (e.g., chat, gaming, streaming).
    

---

## **Why Node.js Came to Market**

### **1\. To Use JavaScript on the Server**

* Until then, JavaScript was only client-side.
    
* Node.js brought **JavaScript to the backend**, enabling full-stack development with a single language.
    

---

### **2\. Non-blocking, Event-Driven Architecture**

* Traditional servers (like Apache with PHP) used **blocking I/O**: one thread waits for tasks (file read, database query) to complete.
    
* Node.js introduced **non-blocking I/O with an event loop**.
    
* This meant:
    
    * One thread can handle thousands of concurrent requests.
        
    * Great for **real-time apps (chat apps, streaming, APIs)**.
        

---

### **3\. High Performance with V8 Engine**

* Built on **Google Chrome's V8 engine**, Node.js executes JavaScript extremely fast.
    
* Compiles JS into machine code.
    

---

### **4\. Scalability and Lightweight**

* Uses **asynchronous callbacks, promises, async/await**.
    
* Runs on a **single-threaded event loop**, consuming fewer resources than multi-threaded servers.
    

---

### **5\. Huge Ecosystem (npm)**

* Node.js brought **npm (Node Package Manager)**, the world’s largest open-source library ecosystem.
    
* Made it easy to install, share, and update packages.
    

---

### **6\. Ideal for Modern Web Apps**

* Real-time chat (WhatsApp Web, Slack)
    
* Streaming services (Netflix, YouTube backend components)
    
* Microservices & APIs
    
* Automation tools (Playwright, Cypress)
    

---

## **In Simple Words**

Node.js came to the market to:

* **Break the wall between frontend and backend** (one language: JavaScript)
    
* **Handle high-concurrency applications efficiently**
    
* **Speed up development with a giant package ecosystem**
    
* **Enable real-time and scalable applications**
    

---

## **Analogy**

Old servers = Waiters who serve one table at a time (blocking).  
Node.js = A smart waiter who takes many orders, delivers them as they’re ready, and never waits idly.

## What is Node Package Manager (npm) is, how it came to exist, and Why it became essential for Node.js and the JavaScript ecosystem.

## **What is npm (Node Package Manager)?**

* **npm** is the default package manager for Node.js.
    
* It allows you to **install, share, manage, and update code packages (libraries, tools, frameworks)**.
    
* It comes bundled with Node.js (no need to install separately).
    

### **What Does npm Do?**

* Installs libraries like Express, React, Playwright, etc.
    
* Manages dependencies in your project via `package.json`.
    
* Allows you to publish your own packages.
    
* Provides access to the **world’s largest open-source library ecosystem**.
    

---

## **How Did npm Come? (The History)**

### **Before npm**

* JavaScript was mostly used in browsers.
    
* Developers relied on manually downloading libraries and linking them with `<script>` tags.
    
* Dependency management was a nightmare:
    
    * No central repository
        
    * Version conflicts (different libraries requiring different versions)
        
    * No standard way to share packages
        

### **The Birth of npm**

* **Created in 2010 by Isaac Z. Schlueter**, shortly after Node.js (2009).
    
* Built to solve:
    
    * **Package sharing** for Node.js
        
    * **Dependency management** in one place
        
    * **Version control** for libraries
        

### **npm's Growth**

* Quickly became the **standard package manager for Node.js**.
    
* Expanded to support frontend tools (React, Angular, Vue, TypeScript, Webpack).
    
* Now used not only in Node.js apps but also for automation, CI/CD, and even Python/.NET integrations.
    

---

## **How npm Works?**

1. You create a project:
    
    ```bash
    npm init -y
    ```
    
    → Creates `package.json` (tracks dependencies and project metadata).
    
2. Install a package:
    
    ```bash
    npm install express
    ```
    
    → Downloads package to `node_modules/` and updates `package.json`.
    
3. Use it in your code:
    
    ```javascript
    const express = require('express');
    ```
    
4. Update or remove packages easily:
    
    ```bash
    npm update
    npm uninstall express
    ```
    
5. Publish your own library:
    
    ```bash
    npm publish
    ```
    

---

## **Why npm is Important ?**

* Makes Node.js scalable and developer-friendly.
    
* Encourages code reuse (no need to rewrite common modules).
    
* Powers tools like Playwright, Selenium WebDriver JS, ESLint, TypeScript, etc.
    
* Became the **largest package ecosystem in the world (2M+ packages)**.
    

---

## **Alternatives to npm ?**

* **Yarn** (Facebook’s alternative, faster installs, better caching).
    
* **pnpm** (space-efficient, symlink-based).
    
* **Bun** (modern, ultra-fast).
    

But npm remains the default and most widely supported.

## **1\. npm Workflow (Step by Step with Diagram)**

Here’s how npm works in a typical Node.js project:

```java
 ┌─────────────────────┐
 │ Install Node.js     │
 │ (npm comes with it) │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Initialize Project  │
 │ npm init -y         │
 │ → creates package.json│
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Install Packages    │
 │ npm install <pkg>   │
 │ → node_modules/     │
 │ → package-lock.json │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Use in Code         │
 │ require()/import    │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Update/Remove       │
 │ npm update / uninstall│
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Share Your Project  │
 │ via package.json    │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Publish Your Package│
 │ npm publish         │
 └─────────────────────┘
```

---

## **2\. Key npm Commands (Automation & Testing Focus)**

### **Project Setup**

* `npm init -y` → Creates a default `package.json`
    
* `npm install` → Installs all dependencies listed in `package.json`
    

### **Installing Tools**

* Playwright:
    
    ```bash
    npm install -D @playwright/test
    npx playwright install
    ```
    
* Selenium WebDriver:
    
    ```bash
    npm install selenium-webdriver
    ```
    
* TypeScript:
    
    ```bash
    npm install -D typescript ts-node @types/node
    ```
    

### **Running Tests**

* Using Playwright:
    
    ```bash
    npx playwright test
    ```
    
* Using Selenium with Node:
    
    ```bash
    node your_test.js
    ```
    

### **Updating Dependencies**

* Update all:
    
    ```bash
    npm update
    ```
    
* Update a specific package:
    
    ```bash
    npm install <package>@latest
    ```
    

### **Other Important Commands**

* `npm list` → View installed packages
    
* `npm outdated` → Check for outdated packages
    
* `npm uninstall <package>` → Remove a package
    
* `npm cache clean --force` → Clear npm cache
    

---

## **3\. npm vs Maven (For Automation Testing)**

You’re already learning **Maven** for Java automation, so here’s a direct comparison:

| **Feature** | **npm (Node.js**) | **Maven (Java)** |
| --- | --- | --- |
| **Language Focus** | JavaScript/TypeScript | Java, Kotlin |
| **Dependency File** | `package.json` | `pom.xml` |
| **Package Repository** | npm registry (2M+ packages) | Maven Central (1M+ packages) |
| **Execution** | `npm run`, `npx` | `mvn clean install`, `mvn test` |
| **Build System** | No default build (Webpack, Rollup, etc.) | Built-in build lifecycle |
| **Test Integration** | Playwright, Jest, Mocha, Cypress | TestNG, JUnit, Selenium |
| **Usage in QA** | Web/API automation (Playwright, Cypress) | Web/API automation (Selenium, REST-Assured) |
| **Installation** | `npm install` (fast, lightweight) | `mvn install` (slower, XML heavy) |

### **When to Use npm in Automation?**

* Playwright, Cypress, Puppeteer automation
    
* API testing with Supertest or Axios
    
* TypeScript-based frameworks
    

### **When to Use Maven in Automation?**

* Selenium + Java/TestNG/JUnit projects
    
* RestAssured, Cucumber with Java
    
* Enterprise CI/CD pipelines using Java stack