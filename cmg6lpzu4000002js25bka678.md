---
title: "TypeScript"
datePublished: Tue Sep 30 2025 13:36:49 GMT+0000 (Coordinated Universal Time)
cuid: cmg6lpzu4000002js25bka678
slug: typescript
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1759343826018/af493aac-724f-44fe-8525-2b238cfee1f5.png
tags: codewithnini

---

## TypeScript

## 📘 Introduction to TypeScript

---

## 🔹 1. What is TypeScript?

* **TypeScript (TS)** is a **superset of JavaScript** created by Microsoft.
    
* Adds **static typing** and modern features to JavaScript.
    
* Code is written in `.ts` files and then **compiled (transpiled)** into plain JavaScript (`.js`) which runs in browsers or Node.js.
    

✅ In short: **JavaScript + Type Safety + Modern Features = TypeScript**

![](https://www.typescripttutorial.net/wp-content/uploads/2020/05/what-is-typescript-compiler.png align="left")

---

## 🔹 2. Why Use TypeScript ?

**The main goals of TypeScript are:**

* Catches errors **at compile time** instead of runtime.
    
* Helps with **autocompletion & IntelliSense** in editors.
    
* Makes **Page Object Models (POM)** more maintainable.
    
* Useful for **scalable frameworks** (many test cases, multiple testers).
    

Example:

```java
let age: number = "25"; // ❌ Error in TypeScript
let age: number = 25;   // ✅ Correct
```

---

## 🔹 3. TypeScript vs JavaScript

| Feature | JavaScript (JS) | TypeScript (TS) |
| --- | --- | --- |
| Typing | Dynamic | Static + Dynamic |
| File extension | `.js` | `.ts` |
| Error checking | Runtime | Compile time |
| IDE support | Limited | Excellent (hints, IntelliSense) |
| Compilation required | ❌ No | ✅ Yes (to JS) |

---

## 🔹 4. TypeScript Workflow

1. Install TypeScript:
    
    ```java
    npm install -g typescript
    ```
    
2. Compile `.ts` to `.js`:
    
    ```java
    tsc file.ts
    ```
    
3. Run JavaScript file with Node.js:
    
    ```java
    node file.js
    ```
    

---

## 🔹 5. Key Features of TypeScript

### ✅ Strong Typing

```java
let user: string = "Nini";
let count: number = 10;
let isLoggedIn: boolean = true;
```

### ✅ Interfaces

Useful for describing object structure.

```java
interface User {
  username: string;
  password: string;
}
const admin: User = { username: "admin", password: "12345" };
```

### ✅ Classes & OOP

Supports **Object-Oriented Programming** (very useful in Playwright POM).

```java
class LoginPage {
  constructor(private page: Page) {}
  async login(user: string, pass: string) {
    await this.page.fill("#username", user);
    await this.page.fill("#password", pass);
    await this.page.click("#submit");
  }
}
```

### ✅ Async/Await

First-class support for handling Promises.

```java
async function run() {
  await page.goto("https://example.com");
}
```

### ✅ Modules

Organize code across files.

```java
// loginPage.ts
export class LoginPage { ... }

// test.ts
import { LoginPage } from './loginPage';
```

---

## 🔹 6. TypeScript in Playwright

Playwright is written in TypeScript itself ✅, so when you use TS:

* Better IntelliSense for locators & methods
    
* Autocomplete for [`page.click`](http://page.click), `page.goto`, etc.
    
* Easy error detection before running tests
    

Example:

```java
import { test, expect } from '@playwright/test';

test('basic test', async ({ page }) => {
  await page.goto('https://example.com');
  await expect(page).toHaveTitle(/Example/);
});
```

---

## 🔹 7. Advantages of Using TypeScript in Automation

* ✅ **Scalability** → Large frameworks are easier to manage.
    
* ✅ **Code readability** → Clearer structure with types, interfaces.
    
* ✅ **IDE support** → Faster coding with autocompletion.
    
* ✅ **Fewer bugs** → Errors caught before running tests.
    
* ✅ **Reusability** → Easy to build Page Objects and utilities.
    

---

⚡ **Summary:**  
TypeScript is a **typed superset of JavaScript** that makes automation frameworks like Playwright **more reliable, maintainable, and developer-friendly**.

# **Before we learn we need to know the some of concepts**.

# why did Node.js come to the market in the first place? What problem did it solve?

## **The Background Before Node.js**

Before 2009 (when Node.js was introduced by Ryan Dahl), most web development looked like this:

* **JavaScript only ran in browsers** (for UI interactions).
    
* Server-side code was written in other languages like PHP, Java, Ruby, or .NET.
    
* Each client request was handled in a **blocking, multi-threaded** way — meaning each connection consumed a thread on the server.
    

This caused:

* **High memory consumption** with many connections.
    
* Poor scalability for real-time apps (e.g., chat, gaming, streaming).
    

---

## **Why Node.js Came to Market**

### **1\. To Use JavaScript on the Server**

* Until then, JavaScript was only client-side.
    
* Node.js brought **JavaScript to the backend**, enabling full-stack development with a single language.
    

---

### **2\. Non-blocking, Event-Driven Architecture**

* Traditional servers (like Apache with PHP) used **blocking I/O**: one thread waits for tasks (file read, database query) to complete.
    
* Node.js introduced **non-blocking I/O with an event loop**.
    
* This meant:
    
    * One thread can handle thousands of concurrent requests.
        
    * Great for **real-time apps (chat apps, streaming, APIs)**.
        

---

### **3\. High Performance with V8 Engine**

* Built on **Google Chrome's V8 engine**, Node.js executes JavaScript extremely fast.
    
* Compiles JS into machine code.
    

---

### **4\. Scalability and Lightweight**

* Uses **asynchronous callbacks, promises, async/await**.
    
* Runs on a **single-threaded event loop**, consuming fewer resources than multi-threaded servers.
    

---

### **5\. Huge Ecosystem (npm)**

* Node.js brought **npm (Node Package Manager)**, the world’s largest open-source library ecosystem.
    
* Made it easy to install, share, and update packages.
    

---

### **6\. Ideal for Modern Web Apps**

* Real-time chat (WhatsApp Web, Slack)
    
* Streaming services (Netflix, YouTube backend components)
    
* Microservices & APIs
    
* Automation tools (Playwright, Cypress)
    

---

## **In Simple Words**

Node.js came to the market to:

* **Break the wall between frontend and backend** (one language: JavaScript)
    
* **Handle high-concurrency applications efficiently**
    
* **Speed up development with a giant package ecosystem**
    
* **Enable real-time and scalable applications**
    

---

## **Analogy**

Old servers = Waiters who serve one table at a time (blocking).  
Node.js = A smart waiter who takes many orders, delivers them as they’re ready, and never waits idly.

## What is Node Package Manager (npm) is, how it came to exist, and Why it became essential for Node.js and the JavaScript ecosystem.

## **What is npm (Node Package Manager)?**

* **npm** is the default package manager for Node.js.
    
* It allows you to **install, share, manage, and update code packages (libraries, tools, frameworks)**.
    
* It comes bundled with Node.js (no need to install separately).
    

### **What Does npm Do?**

* Installs libraries like Express, React, Playwright, etc.
    
* Manages dependencies in your project via `package.json`.
    
* Allows you to publish your own packages.
    
* Provides access to the **world’s largest open-source library ecosystem**.
    

---

## **How Did npm Come? (The History)**

### **Before npm**

* JavaScript was mostly used in browsers.
    
* Developers relied on manually downloading libraries and linking them with `<script>` tags.
    
* Dependency management was a nightmare:
    
    * No central repository
        
    * Version conflicts (different libraries requiring different versions)
        
    * No standard way to share packages
        

### **The Birth of npm**

* **Created in 2010 by Isaac Z. Schlueter**, shortly after Node.js (2009).
    
* Built to solve:
    
    * **Package sharing** for Node.js
        
    * **Dependency management** in one place
        
    * **Version control** for libraries
        

### **npm's Growth**

* Quickly became the **standard package manager for Node.js**.
    
* Expanded to support frontend tools (React, Angular, Vue, TypeScript, Webpack).
    
* Now used not only in Node.js apps but also for automation, CI/CD, and even Python/.NET integrations.
    

---

## **How npm Works?**

1. You create a project:
    
    ```bash
    npm init -y
    ```
    
    → Creates `package.json` (tracks dependencies and project metadata).
    
2. Install a package:
    
    ```bash
    npm install express
    ```
    
    → Downloads package to `node_modules/` and updates `package.json`.
    
3. Use it in your code:
    
    ```javascript
    const express = require('express');
    ```
    
4. Update or remove packages easily:
    
    ```bash
    npm update
    npm uninstall express
    ```
    
5. Publish your own library:
    
    ```bash
    npm publish
    ```
    

---

## **Why npm is Important ?**

* Makes Node.js scalable and developer-friendly.
    
* Encourages code reuse (no need to rewrite common modules).
    
* Powers tools like Playwright, Selenium WebDriver JS, ESLint, TypeScript, etc.
    
* Became the **largest package ecosystem in the world (2M+ packages)**.
    

---

## **Alternatives to npm ?**

* **Yarn** (Facebook’s alternative, faster installs, better caching).
    
* **pnpm** (space-efficient, symlink-based).
    
* **Bun** (modern, ultra-fast).
    

But npm remains the default and most widely supported.

## **1\. npm Workflow (Step by Step with Diagram)**

Here’s how npm works in a typical Node.js project:

```java
 ┌─────────────────────┐
 │ Install Node.js     │
 │ (npm comes with it) │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Initialize Project  │
 │ npm init -y         │
 │ → creates package.json│
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Install Packages    │
 │ npm install <pkg>   │
 │ → node_modules/     │
 │ → package-lock.json │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Use in Code         │
 │ require()/import    │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Update/Remove       │
 │ npm update / uninstall│
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Share Your Project  │
 │ via package.json    │
 └─────────┬───────────┘
           │
           ▼
 ┌─────────────────────┐
 │ Publish Your Package│
 │ npm publish         │
 └─────────────────────┘
```

---

## **2\. Key npm Commands (Automation & Testing Focus)**

### **Project Setup**

* `npm init -y` → Creates a default `package.json`
    
* `npm install` → Installs all dependencies listed in `package.json`
    

### **Installing Tools**

* Playwright:
    
    ```bash
    npm install -D @playwright/test
    npx playwright install
    ```
    
* Selenium WebDriver:
    
    ```bash
    npm install selenium-webdriver
    ```
    
* TypeScript:
    
    ```bash
    npm install -D typescript ts-node @types/node
    ```
    

### **Running Tests**

* Using Playwright:
    
    ```bash
    npx playwright test
    ```
    
* Using Selenium with Node:
    
    ```bash
    node your_test.js
    ```
    

### **Updating Dependencies**

* Update all:
    
    ```bash
    npm update
    ```
    
* Update a specific package:
    
    ```bash
    npm install <package>@latest
    ```
    

### **Other Important Commands**

* `npm list` → View installed packages
    
* `npm outdated` → Check for outdated packages
    
* `npm uninstall <package>` → Remove a package
    
* `npm cache clean --force` → Clear npm cache
    

---

## **3\. npm vs Maven (For Automation Testing)**

You’re already learning **Maven** for Java automation, so here’s a direct comparison:

| **Feature** | **npm (Node.js**) | **Maven (Java)** |
| --- | --- | --- |
| **Language Focus** | JavaScript/TypeScript | Java, Kotlin |
| **Dependency File** | `package.json` | `pom.xml` |
| **Package Repository** | npm registry (2M+ packages) | Maven Central (1M+ packages) |
| **Execution** | `npm run`, `npx` | `mvn clean install`, `mvn test` |
| **Build System** | No default build (Webpack, Rollup, etc.) | Built-in build lifecycle |
| **Test Integration** | Playwright, Jest, Mocha, Cypress | TestNG, JUnit, Selenium |
| **Usage in QA** | Web/API automation (Playwright, Cypress) | Web/API automation (Selenium, REST-Assured) |
| **Installation** | `npm install` (fast, lightweight) | `mvn install` (slower, XML heavy) |

### **When to Use npm in Automation?**

* Playwright, Cypress, Puppeteer automation
    
* API testing with Supertest or Axios
    
* TypeScript-based frameworks
    

### **When to Use Maven in Automation?**

* Selenium + Java/TestNG/JUnit projects
    
* RestAssured, Cucumber with Java
    
* Enterprise CI/CD pipelines using Java stack.
    
    # **Before leaening TypeScript or Playwright just UnderStand the below Topics.**
    

# 📘 JavaScript Modules

---

## 1️⃣ What Are Modules?

* A **module** is a file in JavaScript that **exports** variables, functions, or classes so they can be **imported** in another file.
    
* Modules help **organize code**, **avoid polluting global scope**, and **increase maintainability**.
    

**Example:**

```bash
// mathUtils.js
export function add(a, b) {
  return a + b;
}
export const PI = 3.14;

// main.js
import { add, PI } from './mathUtils.js';
console.log(add(5, 3)); // 8
console.log(PI);        // 3.14
```

✅ Key points:

* Use `export` to make variables/functions/classes available outside the module.
    
* Use `import` to access exported content in another module.
    

---

## 2️⃣ Types of Exports

### Named Export

```bash
// utils.js
export function greet(name) { return `Hello ${name}`; }
export const version = "1.0";

// app.js
import { greet, version } from './utils.js';
console.log(greet("Nini")); // Hello Nini
```

### Default Export

* A module can have **one default export**, which can be imported with any name.
    

```bash
// logger.js
export default function log(message) { console.log(message); }

// app.js
import logFunc from './logger.js';
logFunc("Test started"); // Test started
```

---

## 3️⃣ Dynamic Import

* **Dynamic import** allows importing a module **at runtime**, not at the start.
    
* Returns a **Promise**, useful for **lazy loading modules**.
    

```bash
async function run() {
  const math = await import('./mathUtils.js');
  console.log(math.add(2, 3)); // 5
}
run();
```

✅ Use cases:

* Load modules **only when needed** (performance optimization).
    
* Conditional module loading:
    

```javascript
if (condition) {
  const module = await import('./featureA.js');
  module.runFeature();
}
```

---

## 4️⃣ Top-Level Await in Modules

* **Top-level await** allows using `await` **outside of async functions** at the top of a module.
    
* Only works **inside ES modules** (files with `.js` using `type: "module"` or `.mjs` files).
    

```javascript
// dataLoader.js
const response = await fetch('https://api.example.com/data');
const data = await response.json();
console.log(data);
```

✅ Advantages:

* Makes async initialization simpler.
    
* Useful for loading configuration, test data, or setup before running automation tests.
    

---

## 5️⃣ Using Modules in Node.js / Playwright

* In **Node.js / Playwright**, enable ES modules by:
    
    * Using `"type": "module"` in `package.json`
        
    * Or naming files `.mjs`
        

```json
// package.json
{
  "name": "playwright-project",
  "type": "module"
}
```

* Example in Playwright:
    

```javascript
// pageObjects/loginPage.js
export class LoginPage {
  constructor(page) { this.page = page; }
  async login(user, pass) {
    await this.page.fill('#username', user);
    await this.page.fill('#password', pass);
    await this.page.click('button[type=submit]');
  }
}

// tests/login.test.js
import { test } from '@playwright/test';
import { LoginPage } from '../pageObjects/loginPage.js';

test('login test', async ({ page }) => {
  const login = new LoginPage(page);
  await login.login('admin', '12345');
});
```

---

✅ **Summary:**

* **Modules**: Orga📘 JavaScript Modules
    
    ---
    
    ## 1️⃣ What Are Modules?
    
    * A **module** is a file in JavaScript that **exports** variables, functions, or classes so they can be **imported** in another file.
        
    * Modules help **organize code**, **avoid polluting global scope**, and **increase maintainability**.
        
    
    **Example:**
    
    ```bash
    // mathUtils.js
    export function add(a, b) {
      return a + b;
    }
    export const PI = 3.14;
    
    // main.js
    import { add, PI } from './mathUtils.js';
    console.log(add(5, 3)); // 8
    console.log(PI);        // 3.14
    ```
    
    ✅ Key points:
    
    * Use `export` to make variables/functions/classes available outside the module.
        
    * Use `import` to access exported content in another module.
        
    
    ---
    
    ## 2️⃣ Types of Exports
    
    ### Named Export
    
    ```javascript
    // utils.js
    export function greet(name) { return `Hello ${name}`; }
    export const version = "1.0";
    
    // app.js
    import { greet, version } from './utils.js';
    console.log(greet("Nini")); // Hello Nini
    ```
    
    ### Default Export
    
    * A module can have **one default export**, which can be imported with any name.
        
    
    ```javascript
    // logger.js
    export default function log(message) { console.log(message); }
    
    // app.js
    import logFunc from './logger.js';
    logFunc("Test started"); // Test started
    ```
    
    ---
    
    ## 3️⃣ Dynamic Import
    
    * **Dynamic import** allows importing a module **at runtime**, not at the start.
        
    * Returns a **Promise**, useful for **lazy loading modules**.
        
    
    ```javascript
    async function run() {
      const math = await import('./mathUtils.js');
      console.log(math.add(2, 3)); // 5
    }
    run();
    ```
    
    ✅ Use cases:
    
    * Load modules **only when needed** (performance optimization).
        
    * Conditional module loading:
        
    
    ```javascript
    if (condition) {
      const module = await import('./featureA.js');
      module.runFeature();
    }
    ```
    
    ---
    
    ## 4️⃣ Top-Level Await in Modules
    
    * **Top-level await** allows using `await` **outside of async functions** at the top of a module.
        
    * Only works **inside ES modules** (files with `.js` using `type: "module"` or `.mjs` files).
        
    
    ```javascript
    // dataLoader.js
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
    ```
    
    ✅ Advantages:
    
    * Makes async initialization simpler.
        
    * Useful for loading configuration, test data, or setup before running automation tests.
        
    
    ---
    
    ## 5️⃣ Using Modules in Node.js / Playwright
    
    * In **Node.js / Playwright**, enable ES modules by:
        
        * Using `"type": "module"` in `package.json`
            
        * Or naming files `.mjs`
            
    
    ```json
    // package.json
    {
      "name": "playwright-project",
      "type": "module"
    }
    ```
    
    * Example in Playwright:
        
    
    ```javascript
    // pageObjects/loginPage.js
    export class LoginPage {
      constructor(page) { this.page = page; }
      async login(user, pass) {
        await this.page.fill('#username', user);
        await this.page.fill('#password', pass);
        await this.page.click('button[type=submit]');
      }
    }
    
    // tests/login.test.js
    import { test } from '@playwright/test';
    import { LoginPage } from '../pageObjects/loginPage.js';
    
    test('login test', async ({ page }) => {
      const login = new LoginPage(page);
      await login.login('admin', '12345');
    });
    ```
    
    ---
    
    ✅ **Summary:**
    
    * **Modules**: Organize and export code.
        
    * **Dynamic Import**: Load modules at runtime.
        
    * **Top-level Await**: Use `await` outside async functions at the module top level.
        
    * **Playwright Use**: Modularize POMs, utilities, and test scripts using ES modules.nize and export code.
        
* **Dynamic Import**: Load modules at runtime.
    
* **Top-level Await**: Use `await` outside async functions at the module top level.
    
* **Playwright Use**: Modularize POMs, utilities, and test scripts using ES modules.
    

✅ Let’s compare **JavaScript/TypeScript modules, dynamic import, and top-level await** with **Java equivalents** so it’s easy to relate.

---

## 📊 Comparison: JS Modules vs Java

| Feature | JavaScript / TypeScript | Java Equivalent | Example |
| --- | --- | --- | --- |
| **Modules / Imports** | `export` / `import` | `public class` + `import package.Class` | JS: |
| `js export class Login {} import { Login } from './Login.js';` |  |  |  |
| Java: |  |  |  |
| `java package pages; public class Login {} import pages.Login;` |  |  |  |
| **Named Export / Import** | Multiple exports per file | Multiple public classes or methods in packages | JS: |
| `export function add(){} export const PI=3.14;` |  |  |  |
| Java: |  |  |  |
| `public class MathUtils { public static final double PI=3.14; public static int add(int a,int b){return a+b;} }` |  |  |  |
| **Default Export** | One default export per module | Class itself as main exposed API | JS: |
| `export default class Logger{} import Logger from './Logger.js';` |  |  |  |
| Java: |  |  |  |
| `public class Logger {} // import pages.Logger;` |  |  |  |
| **Dynamic Import** | `import()` at runtime, returns Promise | Reflection or Class.forName() | JS: |
| `const module = await import('./math.js');` |  |  |  |
| Java: |  |  |  |
| `Class<?> clazz = Class.forName("pages.Login"); Object obj = clazz.getDeclaredConstructor().newInstance();` |  |  |  |
| **Top-level Await** | Can use `await` outside async function in module | Java doesn’t allow await at top level; must use `main` or another async context | JS: |
| `const data = await fetch(url);` |  |  |  |
| Java: |  |  |  |
| `CompletableFuture<String> data = httpClient.sendAsync(request, BodyHandlers.ofString()); data.thenAccept(System.out::println);` |  |  |  |

---

### 🔹 Key Observations:

1. **Modules:** Both organize code; JS uses file-based exports, Java uses packages & public classes.
    
2. **Dynamic import:** JS supports runtime loading natively; Java requires reflection (`Class.forName`).
    
3. **Top-level await:** JS modules allow simpler async initialization; Java always needs an **async context** (like `CompletableFuture` or threads).
    

---

### ⚡ Example: Playwright-like Page Object

**JavaScript / TypeScript (Module + POM + Await):**

```javascript
// loginPage.js
export class LoginPage {
  constructor(page) { this.page = page; }
  async login(user, pass) {
    await this.page.fill('#username', user);
    await this.page.fill('#password', pass);
    await this.page.click('#submit');
  }
}

// test.js
import { LoginPage } from './loginPage.js';
const login = new LoginPage(page);
await login.login('admin', '12345');
```

**Java (Selenium Page Object):**

```java
// LoginPage.java
package pages;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.By;

public class LoginPage {
    WebDriver driver;
    public LoginPage(WebDriver driver) { this.driver = driver; }
    public void login(String user, String pass) {
        driver.findElement(By.id("username")).sendKeys(user);
        driver.findElement(By.id("password")).sendKeys(pass);
        driver.findElement(By.id("submit")).click();
    }
}

// LoginTest.java
import pages.LoginPage;
LoginPage login = new LoginPage(driver);
login.login("admin","12345");
```

✅ As you can see:

* **Module import/export** in JS ≈ **package + import** in Java.
    
* **Async / Await** in JS ≈ **WebDriver waits / threads / CompletableFuture** in Java.
    
* Dynamic import in JS ≈ Reflection in Java.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759252853515/0fdc346d-9cfa-41f0-ae49-f10936a0ee04.png align="center")

## Statically and Dynamically Type Language

## **Typing Concepts**

| Feature | Statically Typed Language | Dynamically Typed Language |
| --- | --- | --- |
| **Definition** | Variable types are known at **compile time**. | Variable types are determined at **runtime**. |
| **Type Checking** | Done during compilation. | Done during execution. |
| **Error Detection** | Many type-related errors are caught **before running the code**. | Type errors appear only when the code executes. |
| **Flexibility** | Less flexible, more strict. | More flexible, allows implicit type changes. |
| **Examples** | Java, TypeScript | JavaScript, Python |

---

## **2\. Comparison Using JS, TS, and Java**

### **JavaScript (Dynamically Typed)**

```javascript
let x = 10;    // x is number now
x = "Hello";   // x is now string, no error
console.log(x); // Output: Hello
```

* JS doesn’t enforce types.
    
* A variable can change its type at any time.
    
* Errors like adding a string to a number are only found at runtime.
    

### **TypeScript (Statically Typed)**

```javascript
let x: number = 10;
x = "Hello"; // ❌ Error: Type 'string' is not assignable to type 'number'
```

* TS is statically typed (optional, but recommended).
    
* Types are checked at **compile time**.
    
* Helps catch errors early before running the code.
    
* You can also use `any` type for dynamic behavior:
    

```javascript
let y: any = 10;
y = "Hello"; // ✅ No error
```

### **Java (Statically Typed)**

```javascript
int x = 10;
x = "Hello"; // ❌ Compile-time error
```

* Java is strictly statically typed.
    
* You must declare the type of every variable.
    
* Errors are caught during compilation.
    

## **3\. Key Differences Between JS, TS, and Java**

| Feature | JavaScript | TypeScript | Java |
| --- | --- | --- | --- |
| Typing | Dynamic | Static (optional) | Static |
| Compilation | Interpreted | Compiled to JS | Compiled to bytecode |
| Type Safety | Low | High | Very High |
| Variable Reassignment | Any type | Must follow declared type | Must follow declared type |
| Error Detection | Runtime | Compile-time | Compile-time |
| Popular Use | Web | Web, Large-scale apps | Enterprise, Backend, Android |

### **Summary**

* **JS:** Flexible but prone to runtime errors.
    
* **TS:** Adds static typing to JS → safer, easier to maintain.
    
* **Java:** Fully statically typed → very strict, robust for large apps.
    

### **Type System Comparison Diagram**

```javascript
             +-------------------------+
             |      JavaScript         |
             |  Dynamically Typed      |
             |  Type checked at runtime|
             |  Flexible, but risky   |
             +-------------------------+
                        |
                        v
             +-------------------------+
             |      TypeScript         |
             |  Statically Typed       |
             |  Type checked at compile|
             |  Can catch errors early |
             |  Safer than JS          |
             +-------------------------+
                        |
                        v
             +-------------------------+
             |         Java            |
             |  Statically Typed       |
             |  Strict compile-time    |
             |  Very robust & safe     |
             +-------------------------+
```

---

### **Quick Example Table**

| Language | Variable Declaration | Type Checking | Example Error |
| --- | --- | --- | --- |
| JavaScript | `let x = 10;` | Runtime | `x = "Hello"; // ok at compile, fails at runtime if logic depends on number` |
| TypeScript | `let x: number = 10;` | Compile-time | `x = "Hello"; // ❌ Error at compile time` |
| Java | `int x = 10;` | Compile-time | `x = "Hello"; // ❌ Error at compile time` |

---

✅ **Takeaway:**

* JS = flexible, runtime errors
    
* TS = JS + static type safety
    
* Java = strict static typing
    

# Lets study TypeScript………………………………

## Coomads need to know..

## **📘 Node.js Commands**

| Command | Description |
| --- | --- |
| `node -v` | Check Node.js version |
| `npm -v` | Check npm version |
| `npm init` | Initialize a new project (interactive) |
| `npm init -y` | Initialize a new project with default settings |
| `npm install <package>` | Install package locally |
| `npm install -g <package>` | Install package globally |
| `npm install --save <package>` | Add package to dependencies |
| `npm install --save-dev <package>` | Add package to devDependencies |
| `npm uninstall <package>` | Remove a package |
| `npm update <package>` | Update a package |
| `node app.js` | Run a JS file |
| `nodemon app.js` | Run with auto-reload (requires nodemon) |
| `npm start` | Run start script from package.json |
| `npm run <script>` | Run custom script from package.json |
| `npm list -g --depth=0` | List global packages |
| `npm outdated` | Check outdated packages |
| `node` | Start Node.js REPL (interactive console) |
| `node --inspect app.js` | Debug Node.js file using Chrome DevTools |
| `node --trace-warnings app.js` | Show runtime warnings |

---

## **📘 TypeScript Commands**

| Command | Description |
| --- | --- |
| `npm install -g typescript` | Install TypeScript globally |
| `tsc -v` | Check TypeScript version |
| `tsc --init` | Initialize a TypeScript project (`tsconfig.json`) |
| `tsc app.ts` | Compile a single TypeScript file to JavaScript |
| `tsc` | Compile project using `tsconfig.json` |
| `tsc -w` | Watch mode – automatically compile on file changes |
| `tsc app.ts --target ES6` | Compile TS file targeting ES6 JS |
| `tsc app.ts --outDir ./dist` | Set output directory for compiled JS |
| `tsc app.ts --module commonjs` | Set module system |
| `ts-node app.ts` | Run TypeScript file directly without compiling (requires `ts-node`) |
| `tsc --listFiles` | List all files compiled by TypeScript |
| `tsc --diagnostics` | Show compilation statistics |
| `tsc --init --strict` | Create `tsconfig.json` with strict mode enabled |
| `tslint -c tslint.json 'src/**/*.ts'` | Lint TypeScript files (requires `tslint`) |
| `prettier --write "src/**/*.ts"` | Format TypeScript files (requires `prettier`) |

---

✅ **Tip:**

* **Node.js commands** are mostly for runtime, package management, and debugging.
    
* **TypeScript commands** focus on compilation, type checking, and project configuration.
    

# **01 Introduction to TypeScript**

* TypeScript is a **superset of JavaScript** that adds **static types**.
    
* Compiles to plain JavaScript: `tsc filename.ts`
    
* Advantages:
    
    * Early error detection
        
    * Better IDE support (autocomplete, intellisense)
        
    * Large-scale app maintainability
        

# **02 TypeScript Setup**

The following tools you need to set up to start with TypeScript:

* **Visual Studio Code or VS Code** – a code editor supporting TypeScript.
    
* **Node.js** – Node.js is the environment in which you will run the TypeScript compiler.
    
* **TypeScript compiler** – a Node.js module that compiles TypeScript into JavaScript.
    

If you use VS Code, you can install the following extension to speed up the development process:

* Live Server – allows you to launch a development local web server with the hot reload feature.
    

## **Install Node.js**

**Install** node.js and open Command Prompt on Windows and type the command `node -v`, it should show the installed version of Node.js.

## **Install TypeScript compiler**

To install the TypeScript compiler, you launch the Terminal on macOS or Linux and Command Prompt on Windows and type the following command:

```bash
// global
npm install -g typescript 
// or
// local (This keeps your project self-contained and avoids version mismatches.
npm install --save-dev typescript
```

After the installation, you can type the following command to check the current version of the TypeScript **tsc --v**

It should return the version like this: **Version 5.8.3**

## **Install tsx module**

If you want to run TypeScript code directly on Node.js without precompiling, you can use the `tsx` module.

## **Summary**

* A TypeScript compiler compiles the TypeScript into JavaScript.
    
* Use the `tsc` command to compile a TypeScript file to a JavaScript file.
    
* Use the `tsx` module to run TypeScript directly on Node.js without precompiling it to JavaScript.
    

# **03 TypeScript “Hello, Nini!”**

## **TypeScript Hello Nini program in Node.js**

* launch VS Code create a directory as **TypeScript** and inside create another child directoty as **TypeScript\_Tutorial** . and install all as \*\*local (\*\*This keeps the project self-contained and avoids version mismatches).
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759317474112/99f83038-486c-4f8c-9c18-b2b2197ebb84.png align="center")
    
    Inside **TypeScript\_Tutorial** project create a new directory as **HelloNini** and Inside **HelloNini-derectory** create a new TypeScript file called `app.ts`. The extension of a TypeScript file is `.ts`.
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759317867674/677c3615-b682-474b-ade5-d9ff11b5661f.png align="center")
    
    Here i have added another file as **README.md** file to give extra information about the project.
    
* And type the following source code in the `app.ts` file.
    
    ```typescript
    let message: string = 'Hello, Nini!';
    console.log(message);
    ```
    
    Right-Click on directoty and **open in integrated Terminal** to compile the **.ts** file .
    
* type the following command on the Terminal to compile the `tsc app.ts` and click **enter.**
    
* If everything is fine, you’ll see a new file called `app.js` is generated by the TypeScript compiler.
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759318745101/20e10e14-3032-4d05-9141-3ffa25aafde1.png align="center")
    
    To run the `app.js` file in `Node.js`, type following command in same directory `node app.js` and Click on Enter.
    
* If everything is fine, it will show the output in console.
    
    **OUTPUT:**
    
    ```bash
    hp@NINI MINGW64 /TypeScript/TypeScript_Tutorial/HelloNini (main)
    $ node app.js
    Hello, Nini!
    ```
    

If you installed the `tsx` module you can use just one command to run the TypeScript file directly on Node.js without precompiling it to JavaScript:

```bash
tsx app.ts
```

# **04 Why TypeScript ?**

## **Why use TypeScript**

There are two main reasons to use TypeScript:

* TypeScript adds a type system to help you avoid many problems with dynamic types in JavaScript.
    
* TypeScript implements the future ***features*** of JavaScript **ES Next** so you can use them today.
    

**This tutorial focuses on the first reason.**

## **Understanding dynamic type in JavaScript**

JavaScript is dynamically typed. Unlike statically typed languages such as Java or C#, **values have types instead of variables**.

**JavaScript is dynamically typed**. Let me explain with a clear example.

---

## 🔹 In JavaScript (Dynamically Typed)

* **Variables don’t have fixed types**.
    
* The **value** determines the type, not the variable.
    
* You can reassign different types to the same variable.
    

✅ Example:

```javascript
let value = 42;          // number
console.log(typeof value); // "number"

value = "hello";         // ✅ allowed, now it's a string
console.log(typeof value); // "string"

value = true;            // ✅ allowed, now it's a boolean
console.log(typeof value); // "boolean"
```

👉 Here, **value** of **variable** keeps changing **type** depending on the value.

👉 **Variables** don’t have a fixed **type**, only the **value** has a type.

---

## 🔹 In Java / C# (Statically Typed)

* **Variables have fixed types**.
    
* Once declared, you cannot assign a different type.
    

✅ Java Example:

```java
public class Main {
    public static void main(String[] args) {
        int value = 42;      // int type fixed
        System.out.println(value);

        // value = "hello";  // ❌ ERROR: incompatible types
        // value = true;     // ❌ ERROR: cannot convert boolean to int
    }
}
```

👉Variables **must have a type** and it **cannot change**.

---

## 📊 Key Difference

| **Feature** | **JavaScript** (Dynamic) | **Java**/**C#** (Static) |
| --- | --- | --- |
| Type Binding | At runtime | At compile-time |
| Variable has type? | ❌ No, value has type | ✅ Yes, variable fixed type |
| Flexibility | High (can reassign) | Low (strict typing) |
| Error detection | At runtime | At compile-time |

---

## 🔹 TypeScript (Static Typing on top of JavaScript)

```typescript
let value: number = 42;  
console.log(value);

value = "hello";   // ❌ ERROR: Type 'string' is not assignable to type 'number'
value = true;      // ❌ ERROR: Type 'boolean' is not assignable to type 'number'
```

👉 TypeScript works like Java in terms of typing but **still compiles to JavaScript**.

✅ This is why TypeScript was created → to add **static typing** to JavaScript for better safety. we called it **typeSafety**.

## 📊 Quick Comparison

| Feature | JavaScript | Java | TypeScript |
| --- | --- | --- | --- |
| Typing | Dynamic (runtime) | Static (compile-time) | Static (compile-time, but compiles to JS) |
| Variable type fixed? | ❌ No | ✅ Yes | ✅ Yes |
| Flexibility | High | Low | Medium (strict, but allows `any`) |
| Example behavior | Same variable can be number → string → boolean | Not allowed | Not allowed |

---

⚡ **Summary:**

* JavaScript → variables can hold any type, changes at runtime.
    
* Java → variable type fixed at compile time.
    
* TypeScript → adds Java-like strict typing to JavaScript.
    

# **04 TypeScript Types**

## 🔹 What is a Type in TypeScript?

A **type** in TypeScript is a way to describe the **shape** or **kind of data** a variable, parameter, or function can hold.

* It tells the compiler **what kind of values** are allowed.
    
* Example:
    
    ```javascript
    let age: number = 25;   // type: number
    let name: string = "Nini"; // type: string
    let isAdmin: boolean = true; // type: boolean
    ```
    

👉 In short: A **type is like a contract** that ensures variables and functions are used correctly.

---

## 🔹 Types in TypeScript

Types are broadly categorized into **two groups**:

### 1\. **Primitive Types**

Basic building blocks (same as in Java/JavaScript but with strict typing).

* `number` → integers, floats, etc.
    
* `string` → text values
    
* `boolean` → true/false
    
* `null`
    
* `undefined`
    
* `bigint` → very large numbers
    
* `symbol` → unique identifiers
    

✅ Example:

```javascript
let count: number = 10;
let username: string = "Nini";
let loggedIn: boolean = false;
```

---

### 2\. **Special & Advanced Types**

* `any` → can hold **anything** (least safe).
    
* `unknown` → safer alternative to `any` (must check before using).
    
* `void` → function doesn’t return anything.
    
* `never` → function never returns (e.g., throws error).
    
* `object` → non-primitive values.
    
* `array` → list of elements (`number[]`, `string[]`).
    
* `tuple` → fixed-size array with known types.
    
* `enum` → named constants.
    
* **Custom types** → `type` and `interface`.
    

✅ Example:

```javascript
let data: any = 42; // can be number, string, etc.
let values: number[] = [1, 2, 3];
let tupleEx: [string, number] = ["Age", 25];

enum Role { Admin, User, Guest }
let role: Role = Role.Admin;
```

---

## 🔹 **Purposes of types in TypeScript**

There are two main purposes of types in TypeScript:

* First, types are used by the TypeScript compiler to analyze your code for **errors**.
    
* Second, types allow you to understand what values are associated with variables.
    

1. **Error Prevention (Safety)**
    
    * Catches mistakes at compile time (before running).
        
    
    ```javascript
    let age: number = 25;
    age = "twenty-five"; // ❌ ERROR
    ```
    
2. **Readability & Documentation**
    
    * Makes code easier to understand.
        
    
    ```javascript
    function greet(name: string): string {
      return "Hello, " + name;
    }
    ```
    
    **Other Purpose are :**
    
    **IntelliSense & Autocomplete**
    
    * Editors (like VS Code) can suggest methods and properties.
        
    
    **Scalability**
    
    * Large teams/projects benefit from predictable types.
        
    
    **Better Refactoring**
    
    * Changing a type propagates errors/warnings across the codebase, helping avoid bugs.
        

---

## 📊 Quick Summary

| Feature | Description |
| --- | --- |
| **Type** | Defines what kind of data a variable/function can hold |
| **Types in TS** | Primitive (number, string, boolean, etc.), Special (`any`, `void`, `never`), Advanced (`array`, `tuple`, `enum`, `interface`, `type`) |
| **Purpose** | Safety, readability, better tooling (IntelliSense), scalability, refactoring |

👍 **TypeScript Types Cheatsheet** 📒 — with categories, definitions, and examples for quick reference.

---

## 📘 TypeScript Types Cheatsheet

## 🔹 1. Primitive Types

| Type | Description | Example |
| --- | --- | --- |
| `number` | Numeric values (int, float, hex, binary) | `let age: number = 25;` |
| `string` | Text values | `let name: string = "Nini";` |
| `boolean` | True/False | `let isAdmin: boolean = true;` |
| `null` | Null value | `let x: null = null;` |
| `undefined` | Undefined value | `let y: undefined = undefined;` |
| `bigint` | Very large integers | `let big: bigint = 9007199254740991n;` |
| `symbol` | Unique identifier | `let sym: symbol = Symbol("id");` |

## 🔹 2. Special Types

| Type | Description | Example |
| --- | --- | --- |
| `any` | Can be **anything** (disables type checking) | `let data: any = "text"; data = 123;` |
| `unknown` | Like `any` but safer (must check type first) | `let val: unknown = "hi"; if (typeof val === "string") console.log(val.toUpperCase());` |
| `void` | No return value (usually for functions) | `function log(msg: string): void { console.log(msg); }` |
| `never` | Function never returns (infinite loop or error) | `function fail(): never { throw new Error("Error!"); }` |
| `object` | Any non-primitive object | `let obj: object = {name: "Nini"};` |

## 🔹 3. Structured Types

| Type | Description | Example |
| --- | --- | --- |
| `array` | Collection of same type | `let nums: number[] = [1, 2, 3];` |
| `tuple` | Fixed-size array with specific types | `let tupleEx: [string, number] = ["Age", 25];` |
| `enum` | Named constants | `enum Role { Admin, User, Guest } let r: Role = Role.Admin;` |

## 🔹 4. Function Types

| Type | Description | Example |
| --- | --- | --- |
| Function parameters & return | Explicit typing of arguments and return value | `function add(a: number, b: number): number { return a + b; }` |
| Optional parameter | Parameter may or may not be provided | \`function greet(name?: string) { return "Hi " + (name |
| Default parameter | Has a default value | `function greet(name: string = "Guest") { return "Hi " + name; }` |

## 🔹 5. Advanced Types

| Type | Description | Example |
| --- | --- | --- |
| `union` | Multiple possible types | \`let id: number |
| `intersection` | Combine multiple types | `type A = {x: number}; type B = {y: string}; let obj: A & B = {x: 1, y: "hi"};` |
| `type alias` | Custom name for a type | \`type ID = number |
| `interface` | Structure for objects/classes | `interface User { id: number; name: string; } let u: User = {id: 1, name: "Nini"};` |
| `literal` | Specific allowed values | \`let status: "success" |
| `generics` | Reusable type placeholders | `function identity<T>(arg: T): T { return arg; } let output = identity<string>("Hello");` |

# **05 Type Annotations**

## 🔹 What is Type Annotation in TypeScript?

**Type annotation** is when you explicitly **declare the type** of a **variable**, **constant**, **function parameter**, or **return type**.

* It tells the compiler: “This **variable** should **only** hold values of this type.”
    
* TypeScript will throw an error if you try to assign a value of a different type.
    

Syntax:

```typescript
let variableName: type = value;
```

---

## 🔹 Type Annotations in Variables and Constants

### 1\. Variables

```typescript
let age: number = 25;          // number type
let name: string = "Nini";     // string type
let isAdmin: boolean = true;   // boolean type
```

### 2\. Constants

```typescript
const userName: string = "Nini"; // string constant
const pi: number = 3.14;         // number constant
```

> ⚡ Note: Constants with `const` must be initialized when declared.

---

## 🔹 Type Annotation Examples

### 1\. Arrays

```typescript
let numbers: number[] = [1, 2, 3];
let names: string[] = ["Nini", "Alice"];
```

### 2\. Tuples

```typescript
let user: [string, number] = ["Nini", 25]; // fixed-size: name + age
```

### 3\. Functions

```typescript
function greet(name: string): string {
    return "Hello, " + name;
}

console.log(greet("Nini"));
```

### 4\. Objects

```typescript
let person: { name: string; age: number; isAdmin: boolean } = {
    name: "Nini",
    age: 25,
    isAdmin: true
};
```

### 5\. Union Types

```typescript
let id: number | string;
id = 101;
id = "Nini123";
```

### 6\. Any / Unknown

```typescript
let data: any = 42;
data = "Nini";   // ✅ allowed

let unknownData: unknown = "Nini";
// unknownData.toUpperCase(); ❌ ERROR: Type must be checked first
if (typeof unknownData === "string") {
    console.log(unknownData.toUpperCase()); // ✅ safe
}
```

---

## 🔹 Summary

| Feature | Example |
| --- | --- |
| Variable Annotation | `let name: string = "Nini";` |
| Constant Annotation | `const userName: string = "Nini";` |
| Array Annotation | `let names: string[] = ["Nini"];` |
| Tuple | `let user: [string, number] = ["Nini", 25];` |
| Object Annotation | `let person: { name: string; age: number } = { name: "Nini", age: 25 };` |
| Function Parameter & Return | `function greet(name: string): string { return "Hello, " + name; }` |
| Union Type | \`let id: number |
| Any / Unknown | `let data: any = "Nini";` |

# **06 Type Inference**

## 🔹 1. Basic Type Inference

**Type inference** is when TypeScript **automatically determines the type** of a variable based on its value, without an explicit type annotation.

✅ Example:

```typescript
let name = "Nini";    // TypeScript infers type as string
let age = 25;         // inferred as number
let isAdmin = true;   // inferred as boolean
```

> You don’t need to write `:string` or `:number` here.  
> TypeScript guesses the type from the assigned value.

---

## 🔹 2. The Best Common Type Algorithm

* TypeScript tries to **find a single type that works for multiple values**.
    
* If values have **different types**, TypeScript tries to pick a **common type**.
    

✅ Example:

```typescript
let arr = ["Nini", "Alice", "Bob"]; // inferred as string[]
let mixed = [1, 2, "Nini"];         // inferred as (string | number)[]
```

> TypeScript looks at all elements and picks the **best common type** that fits all values.

---

## 🔹 3. Contextual Typing

* TypeScript can **infer types from context**, like function parameters or object properties.
    
* The type is **not explicit**, but TypeScript knows it based on where the value is used.
    

✅ Example:

```typescript
window.onmousedown = function(event) {
    console.log(event.button); // event is inferred as MouseEvent
};

let greet: (name: string) => string = function(n) {
    return "Hello, " + n;
};
console.log(greet("Nini"));
```

> The compiler infers `event` and `n` types from context.

---

## 🔹 4. Type Inference vs Type Annotations

| Feature | Type Inference | Type Annotation |
| --- | --- | --- |
| Explicitly written? | ❌ No | ✅ Yes |
| Compiler assigns type? | ✅ Yes, automatically | ❌ You specify it |
| Example | `let age = 25; // inferred as number` | `let age: number = 25;` |
| Use Case | Quick, safe for simple cases | Needed for complex types, clarity, or API contracts |
| Flexibility | Less typing, but still safe | Guarantees exact type, prevents mistakes |

---

## 🔹 5. Summary

* **Type Inference** → TypeScript guesses the type based on value or context.
    
* **Best Common Type Algorithm** → Picks a type that fits all elements in arrays or unions.
    
* **Contextual Typing** → Type inferred based on usage (like parameters or events).
    
* **Type Inference vs Type Annotation** → Inference = automatic, Annotation = explicit.
    

✅ Example combining everything:

```typescript
let name = "Nini";                    // inferred string
let mixed: (string | number)[] = [1, "Nini"]; // explicit union type
function greet(n: string) {           // type annotation
    console.log("Hello, " + n);
}
let clickHandler = (event) => {       // contextual typing
    console.log(event.button);
};
```

# 07 Control Flow Statements in TypeScript 🚦

## 1️⃣ Conditional Statements ❓

### a) `if` / `else if` / `else`

```typescript
let age: number = 20;

if (age >= 18) {
    console.log("🎉 Nini is an adult!");
} else if (age > 12) {
    console.log("👦 Nini is a teenager");
} else {
    console.log("🍼 Nini is a child");
}
```

### b) Ternary Operator `? :` ⚡

```typescript
let isAdmin: boolean = true;
console.log(isAdmin ? "🛡️ Nini is admin" : "👤 Nini is user");
```

### c) `switch` statement 🔄

```typescript
let role: string = "Admin";

switch (role) {
    case "Admin":
        console.log("🛡️ Nini can manage users");
        break;
    case "User":
        console.log("👤 Nini can view content");
        break;
    case "Guest":
        console.log("👻 Nini has limited access");
        break;
    default:
        console.log("❌ Role not recognized");
}
```

---

## 2️⃣ Loops 🔁

### a) `for` loop 🔄

```typescript
let names: string[] = ["Nini", "Alice", "Bob"];
for (let i = 0; i < names.length; i++) {
    console.log("👋 Hello " + names[i]);
}
```

### b) `for...of` loop ✨ (ES6 style)

```typescript
for (let name of names) {
    console.log("👋 Hello " + name);
}
```

### c) `for...in` loop 🔑 (for object keys)

```typescript
let person = { name: "Nini", age: 25, isAdmin: true };
for (let key in person) {
    console.log(`${key} => ${person[key as keyof typeof person]}`);
}
```

### d) `while` loop ⏳

```typescript
let count = 3;
while (count > 0) {
    console.log("⏳ Countdown: " + count);
    count--;
}
```

### e) `do...while` loop 🌀

```typescript
let num = 1;
do {
    console.log("🌀 Num is " + num);
    num++;
} while (num <= 3);
```

---

## 3️⃣ Jump Statements 🚀

* `break` → Exit a loop early
    
* `continue` → Skip current iteration
    
* `return` → Exit a function
    
* `throw` → Raise an error
    

✅ Example:

```typescript
for (let i = 1; i <= 5; i++) {
    if (i === 3) continue; // skip 3
    if (i === 5) break;    // stop at 5
    console.log("Loop i =", i);
}

function greet(name: string): void {
    if (!name) throw new Error("❌ Name required");
    console.log("Hello, " + name);
}

greet("Nini");
```

---

## 4️⃣ Summary Table 📊

| Type | Example | Emoji Hint |
| --- | --- | --- |
| `if / else if / else` | Conditional branching | ❓ |
| Ternary `? :` | Short if-else | ⚡ |
| `switch` | Multi-choice branching | 🔄 |
| `for` | Classic loop | 🔁 |
| `for...of` | Array/iterable loop | ✨ |
| `for...in` | Object keys loop | 🔑 |
| `while` | Pre-check loop | ⏳ |
| `do...while` | Post-check loop | 🌀 |
| `break` | Exit loop | 🚪 |
| `continue` | Skip iteration | ⏭️ |
| `return` | Exit function | 🏁 |
| `throw` | Error | ❌ |

# **08 TypeScript Functions**

## 🔹 1. Introduction to TypeScript Functions 🔹

Functions are **blocks of code** designed to perform a specific task.  
TypeScript adds **type safety** to JavaScript functions by allowing you to **define types for parameters and return values**.

### ✅ Basic Function Syntax

```typescript
function greet(name: string): string {
    return "Hello, " + name + " 👋";
}

console.log(greet("Nini")); // Output: Hello, Nini 👋
```

* `name: string` → Parameter type annotation
    
* `: string` after parentheses → Return type annotation
    

---

### 🔹 Features of TypeScript Functions

1. **Typed Parameters** – ensures correct argument types
    
2. **Typed Return Values** – ensures function returns correct type
    
3. **Optional Parameters** – marked with `?`
    
4. **Default Parameters** – assign default values
    
5. **Rest Parameters** – gather multiple arguments into an array
    
6. **Function Types** – describe functions as types
    

---

## 🔹 2. TypeScript Function Types

Function types **describe the signature of a function** — the types of its parameters and return type.

### 1️⃣ Example: Basic Function Type

```typescript
let greetFn: (name: string) => string;

greetFn = function(name: string): string {
    return "Hello, " + name;
};

console.log(greetFn("Nini"));
```

> `(name: string) => string` → function type: takes a string, returns a string

---

### 2️⃣ Optional Parameters `?`

```typescript
function greetOptional(name?: string): string {
    return "Hello, " + (name || "Nini");
}

console.log(greetOptional());      // Hello, Nini
console.log(greetOptional("Alice")); // Hello, Alice
```

---

### 3️⃣ Default Parameters

```typescript
function greetDefault(name: string = "Nini"): string {
    return "Hello, " + name;
}

console.log(greetDefault());       // Hello, Nini
console.log(greetDefault("Alice")); // Hello, Alice
```

---

### 4️⃣ Rest Parameters `...args`

```typescript
function greetAll(...names: string[]): string {
    return "Hello, " + names.join(", ");
}

console.log(greetAll("Nini", "Alice", "Bob")); // Hello, Nini, Alice, Bob
```

---

### 5️⃣ Void Functions

* Functions that **don’t return anything** use `void`.
    

```typescript
function sayHi(name: string): void {
    console.log("Hi, " + name);
}

sayHi("Nini"); // prints Hi, Nini
```

---

### 6️⃣ Function Types as Aliases

```typescript
type GreetFn = (name: string) => string;

let greetUser: GreetFn = (name) => "Hello, " + name;

console.log(greetUser("Nini"));
```

---

## 🔹 Summary Table 📊

| Feature | Syntax | Example |
| --- | --- | --- |
| Typed Parameters | `(param: type)` | `name: string` |
| Typed Return | `(): type` | `(): string` |
| Optional Parameter | `param?: type` | `name?: string` |
| Default Parameter | `param: type = value` | `name: string = "Nini"` |
| Rest Parameter | `...param: type[]` | `...names: string[]` |
| Void Function | `(): void` | `function sayHi(): void { ... }` |
| Function Type | `(param: type) => type` | `(name: string) => string` |
| Function Type Alias | `type Fn = (param) => type` | `type GreetFn = (name: string) => string` |

---

✅ **Key Takeaways:**

* TypeScript functions enforce **type safety** for parameters and return values.
    
* Use **optional/default/rest parameters** for flexibility.
    
* **Function types** help describe functions as first-class citizens.
    

## 🔹3. Function Overloading in TypeScript 🔹

**Function overloading** allows a single function to have **multiple signatures** — different ways it can be called — **with different parameter types or counts**, but with **one implementation**.

* TypeScript uses **function signatures** to define the overloads.
    
* Only **one actual implementation** is written.
    

---

## 🔹 Syntax

```typescript
function functionName(param: type1): returnType;
function functionName(param: type2): returnType;
function functionName(param: any): any {
    // implementation
}
```

> The first lines are **overload signatures**. The last function is the **implementation**.

---

## 🔹 Example 1: Simple Overloading

```typescript
// Overload signatures
function greet(name: string): string;
function greet(name: string, age: number): string;

// Implementation
function greet(name: string, age?: number): string {
    if (age !== undefined) {
        return `Hello, ${name} 👋, Age: ${age}`;
    } else {
        return `Hello, ${name} 👋`;
    }
}

// Usage
console.log(greet("Nini"));         // Hello, Nini 👋
console.log(greet("Nini", 25));     // Hello, Nini 👋, Age: 25
```

✅ Notes:

* `age` is optional in the implementation.
    
* Signatures define **allowed ways to call the function**.
    

---

## 🔹 Example 2: Overloading with Different Types

```typescript
// Overload signatures
function combine(a: string, b: string): string;
function combine(a: number, b: number): number;

// Implementation
function combine(a: any, b: any): any {
    return a + b;
}

// Usage
console.log(combine("Nini", " Rocks"));  // "Nini Rocks"
console.log(combine(10, 20));            // 30
```

✅ Notes:

* The implementation uses `any` type to cover all cases.
    
* Overload signatures restrict how users can call the function.
    

---

## 🔹 Why Use Function Overloading?

1. **Flexibility** – Same function name, multiple behaviors
    
2. **Type Safety** – TypeScript ensures correct usage based on signatures
    
3. **Readability** – Clear documentation for function usage
    

---

## 🔹 Summary Table 📊

| Concept | Example | Notes |
| --- | --- | --- |
| Single parameter | `greet(name: string)` | Basic function call |
| Multiple parameters | `greet(name: string, age: number)` | Optional in implementation |
| Different types | `combine(a: string, b: string)` or `(a: number, b: number)` | Overloaded function signatures |
| Implementation | `function greet(name: string, age?: number)` | Only **one actual function body** |

---

✅ **Key Takeaways:**

* Overload **signatures** define allowed calls.
    
* Only **one implementation** exists.
    
* Makes functions **flexible and type-safe**.
    

# **09 TypeScript Class Interface**

## 🔹 1. Introduction to TypeScript Classes 🏫

* A **class** is a blueprint for creating objects with **properties (data)** and **methods (functions)**.
    
* TypeScript classes are similar to **Java/C# classes** but compile to **JavaScript ES5/ES6 classes**.
    
* Supports **OOP concepts**: encapsulation, inheritance, abstraction, and polymorphism.
    

---

## 🔹 2. Basic Class Syntax

```typescript
class Person {
    name: string;    // property
    age: number;     // property

    constructor(name: string, age: number) { // constructor
        this.name = name;
        this.age = age;
    }

    greet(): string {   // method
        return `Hello, ${this.name} 👋`;
    }
}

// Create object
let nini = new Person("Nini", 25);
console.log(nini.greet()); // Hello, Nini 👋
```

✅ Notes:

* `constructor` → initializes object properties
    
* `this` → refers to the current instance
    

---

## 🔹 3. Access Modifiers 🔐

TypeScript supports **access modifiers** like Java:

| Modifier | Visibility | Example |
| --- | --- | --- |
| `public` | Anywhere | default, accessible outside class |
| `private` | Only inside class | cannot access outside |
| `protected` | Class & subclasses | accessible in class and derived class |

### Example:

```typescript
class Person {
    public name: string;
    private ssn: string;
    protected age: number;

    constructor(name: string, ssn: string, age: number) {
        this.name = name;
        this.ssn = ssn;
        this.age = age;
    }

    showSSN() {
        return `SSN: ${this.ssn}`;
    }
}

let nini = new Person("Nini", "123-45-6789", 25);
console.log(nini.name);       // ✅ Nini
// console.log(nini.ssn);     // ❌ Error: private
// console.log(nini.age);     // ❌ Error: protected
console.log(nini.showSSN());  // ✅ SSN: 123-45-6789
```

---

## 🔹 4. Readonly Properties 📝

* `readonly` → can be assigned **only once** (during declaration or in constructor).
    

```typescript
class Person {
    readonly name: string;

    constructor(name: string) {
        this.name = name;
    }
}

let nini = new Person("Nini");
// nini.name = "Alice"; // ❌ Error: readonly
```

---

## 🔹 5. Parameter Properties (Shortcut) ⚡

* You can declare **properties directly in constructor parameters** using access modifiers.
    

```typescript
class Person {
    constructor(public name: string, private age: number) {}

    greet() {
        return `Hello, ${this.name} 👋`;
    }
}

let nini = new Person("Nini", 25);
console.log(nini.greet());  // Hello, Nini 👋
```

---

## 🔹 6. Inheritance & `extends` 🔼

* Classes can **inherit** properties and methods from a parent class.
    

```typescript
class Employee extends Person {
    constructor(name: string, age: number, public jobTitle: string) {
        super(name, age); // call parent constructor
    }

    showJob() {
        return `${this.name} works as ${this.jobTitle}`;
    }
}

let niniEmp = new Employee("Nini", 25, "Developer");
console.log(niniEmp.greet());    // Hello, Nini 👋
console.log(niniEmp.showJob());  // Nini works as Developer
```

---

## 🔹 7. Getters & Setters 💡

* **Getter** → access property
    
* **Setter** → modify property with validation
    

```typescript
class Person {
    private _age: number;

    constructor(public name: string, age: number) {
        this._age = age;
    }

    get age() {
        return this._age;
    }

    set age(value: number) {
        if (value < 0) throw new Error("Age cannot be negative ❌");
        this._age = value;
    }
}

let nini = new Person("Nini", 25);
console.log(nini.age); // 25
nini.age = 30;         // ✅ works
// nini.age = -5;      // ❌ Error
```

---

## 🔹 8. Static Properties & Methods 🏷️

* `static` → belongs to the **class**, not instances
    

```typescript
class Person {
    static species: string = "Homo sapiens";

    static info() {
        return `Species: ${Person.species}`;
    }
}

console.log(Person.species);  // Homo sapiens
console.log(Person.info());   // Species: Homo sapiens
```

---

## 🔹 9. Abstract Classes & Methods 🏛️

* `abstract` → class cannot be instantiated directly
    
* Must be **extended**
    
* Can contain **abstract methods** (must be implemented in derived class)
    

```typescript
abstract class Person {
    constructor(public name: string) {}
    abstract greet(): string;
}

class Employee extends Person {
    greet() {
        return `Hello, ${this.name} 👋`;
    }
}

let nini = new Employee("Nini");
console.log(nini.greet()); // Hello, Nini 👋
```

---

## 🔹 10. Interfaces with Classes 🧩

* Classes can **implement interfaces** to enforce structure
    

```typescript
interface IPerson {
    name: string;
    greet(): string;
}

class Person implements IPerson {
    constructor(public name: string) {}
    greet() {
        return `Hello, ${this.name} 👋`;
    }
}

let nini = new Person("Nini");
console.log(nini.greet()); // Hello, Nini 👋
```

---

## 🔹 11. Summary Table 📊

| Feature | Syntax / Example | Notes |
| --- | --- | --- |
| Basic Class | `class Person { ... }` | Properties + methods |
| Constructor | `constructor(...) { ... }` | Initializes object |
| Access Modifiers | `public/private/protected` | Control visibility |
| Readonly | `readonly name: string` | Assign once |
| Parameter Properties | `constructor(public name: string)` | Shortcut for property declaration |
| Inheritance | `class Employee extends Person` | `super()` calls parent constructor |
| Getters/Setters | `get age() {...} set age(...) {...}` | Controlled access |
| Static | `static species` | Belongs to class, not instance |
| Abstract Class | `abstract class` | Cannot instantiate, must extend |
| Interface | `implements IPerson` | Enforce class structure |

---

✅ **Key Takeaways**

* TypeScript classes are **powerful for OOP** and similar to Java/C#.
    
* **Access modifiers, static, readonly, inheritance, abstract classes** make code safe and reusable.
    
* Use **interfaces + classes** together for **type safety and structure**.
    

# **10 TypeScript Interface**

## 🔹 1. What is an Interface? 🧩

* An **interface** defines the **shape of an object**: what properties and methods it should have.
    
* It’s a **TypeScript-only feature** (does not exist in JavaScript at runtime).
    
* Helps with **type safety, code readability, and consistency**.
    

---

## 🔹 2. Basic Interface Syntax

```typescript
interface Person {
    name: string;
    age: number;
}

let nini: Person = {
    name: "Nini",
    age: 25
};

console.log(nini.name); // Nini
console.log(nini.age);  // 25
```

✅ Notes:

* `Person` interface enforces that **objects must have** `name` and `age`.
    

---

## 🔹 3. Optional Properties ❓

* Some properties may not always exist.
    

```typescript
interface Person {
    name: string;
    age?: number;  // optional
}

let nini: Person = { name: "Nini" }; // ✅ allowed
```

---

## 🔹 4. Readonly Properties 📝

* Properties that **cannot be changed after assignment**.
    

```typescript
interface Person {
    readonly name: string;
    age: number;
}

let nini: Person = { name: "Nini", age: 25 };
// nini.name = "Alice"; // ❌ Error: readonly
```

---

## 🔹 5. Methods in Interface

```typescript
interface Person {
    name: string;
    greet(): string;
}

let nini: Person = {
    name: "Nini",
    greet() {
        return `Hello, ${this.name} 👋`;
    }
};

console.log(nini.greet()); // Hello, Nini 👋
```

---

## 🔹 6. Extending Interfaces 🔼

* Interfaces can **extend other interfaces** to reuse properties.
    

```typescript
interface Person {
    name: string;
    age: number;
}

interface Employee extends Person {
    jobTitle: string;
}

let nini: Employee = {
    name: "Nini",
    age: 25,
    jobTitle: "Developer"
};
```

---

## 🔹 7. Implementing Interfaces in Classes 🏫

```typescript
interface Person {
    name: string;
    greet(): string;
}

class Developer implements Person {
    constructor(public name: string) {}
    greet(): string {
        return `Hello, ${this.name} 👋`;
    }
}

let niniDev = new Developer("Nini");
console.log(niniDev.greet()); // Hello, Nini 👋
```

---

## 🔹 8. Indexable Types 🔑

* Define **dynamic property names**.
    

```typescript
interface StringArray {
    [index: number]: string;
}

let names: StringArray = ["Nini", "Alice", "Bob"];
console.log(names[0]); // Nini
```

---

## 🔹 9. Function Types in Interfaces 🧩

```typescript
interface Greet {
    (name: string): string;
}

let greet: Greet = (name) => `Hello, ${name} 👋`;
console.log(greet("Nini")); // Hello, Nini 👋
```

---

## 🔹 10. Summary Table 📊

| Feature | Syntax / Example | Notes |
| --- | --- | --- |
| Basic Interface | `interface Person { name: string; age: number }` | Enforces object shape |
| Optional Property | `age?: number` | Not required |
| Readonly Property | `readonly name: string` | Cannot modify |
| Method | `greet(): string` | Define functions in interface |
| Extend Interface | `interface Employee extends Person` | Inherit properties |
| Implement in Class | `class Dev implements Person` | Must include all properties & methods |
| Indexable Types | `[index: number]: string` | Dynamic property names |
| Function Types | `(name: string) => string` | Interface as function type |

---

✅ **Key Takeaways**

* Interfaces are **blueprints for objects, functions, and classes**.
    
* Supports **optional, readonly, methods, function types, indexable types**.
    
* Can **extend other interfaces** and be **implemented by classes**.
    

# **Advanced Types**