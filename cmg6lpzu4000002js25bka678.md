---
title: "TypeScript"
datePublished: Tue Sep 30 2025 13:36:49 GMT+0000 (Coordinated Universal Time)
cuid: cmg6lpzu4000002js25bka678
slug: typescript
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1759343826018/af493aac-724f-44fe-8525-2b238cfee1f5.png
tags: codewithnini

---

## TypeScript

## ğŸ“˜ Introduction to TypeScript

---

## ğŸ”¹ 1. What is TypeScript?

* **TypeScript (TS)** is a **superset of JavaScript** created by Microsoft.
    
* Adds **static typing** and modern features to JavaScript.
    
* Code is written in `.ts` files and then **compiled (transpiled)** into plain JavaScript (`.js`) which runs in browsers or Node.js.
    

âœ… In short: **JavaScript + Type Safety + Modern Features = TypeScript**

![](https://www.typescripttutorial.net/wp-content/uploads/2020/05/what-is-typescript-compiler.png align="left")

---

## ğŸ”¹ 2. Why Use TypeScript ?

**The main goals of TypeScript are:**

* Catches errors **at compile time** instead of runtime.
    
* Helps with **autocompletion & IntelliSense** in editors.
    
* Makes **Page Object Models (POM)** more maintainable.
    
* Useful for **scalable frameworks** (many test cases, multiple testers).
    

Example:

```java
let age: number = "25"; // âŒ Error in TypeScript
let age: number = 25;   // âœ… Correct
```

---

## ğŸ”¹ 3. TypeScript vs JavaScript

| Feature | JavaScript (JS) | TypeScript (TS) |
| --- | --- | --- |
| Typing | Dynamic | Static + Dynamic |
| File extension | `.js` | `.ts` |
| Error checking | Runtime | Compile time |
| IDE support | Limited | Excellent (hints, IntelliSense) |
| Compilation required | âŒ No | âœ… Yes (to JS) |

---

## ğŸ”¹ 4. TypeScript Workflow

1. Install TypeScript:
    
    ```java
    npm install -g typescript
    ```
    
2. Compile `.ts` to `.js`:
    
    ```java
    tsc file.ts
    ```
    
3. Run JavaScript file with Node.js:
    
    ```java
    node file.js
    ```
    

---

## ğŸ”¹ 5. Key Features of TypeScript

### âœ… Strong Typing

```java
let user: string = "Nini";
let count: number = 10;
let isLoggedIn: boolean = true;
```

### âœ… Interfaces

Useful for describing object structure.

```java
interface User {
  username: string;
  password: string;
}
const admin: User = { username: "admin", password: "12345" };
```

### âœ… Classes & OOP

Supports **Object-Oriented Programming** (very useful in Playwright POM).

```java
class LoginPage {
  constructor(private page: Page) {}
  async login(user: string, pass: string) {
    await this.page.fill("#username", user);
    await this.page.fill("#password", pass);
    await this.page.click("#submit");
  }
}
```

### âœ… Async/Await

First-class support for handling Promises.

```java
async function run() {
  await page.goto("https://example.com");
}
```

### âœ… Modules

Organize code across files.

```java
// loginPage.ts
export class LoginPage { ... }

// test.ts
import { LoginPage } from './loginPage';
```

---

## ğŸ”¹ 6. TypeScript in Playwright

Playwright is written in TypeScript itself âœ…, so when you use TS:

* Better IntelliSense for locators & methods
    
* Autocomplete for [`page.click`](http://page.click), `page.goto`, etc.
    
* Easy error detection before running tests
    

Example:

```java
import { test, expect } from '@playwright/test';

test('basic test', async ({ page }) => {
  await page.goto('https://example.com');
  await expect(page).toHaveTitle(/Example/);
});
```

---

## ğŸ”¹ 7. Advantages of Using TypeScript in Automation

* âœ… **Scalability** â†’ Large frameworks are easier to manage.
    
* âœ… **Code readability** â†’ Clearer structure with types, interfaces.
    
* âœ… **IDE support** â†’ Faster coding with autocompletion.
    
* âœ… **Fewer bugs** â†’ Errors caught before running tests.
    
* âœ… **Reusability** â†’ Easy to build Page Objects and utilities.
    

---

âš¡ **Summary:**  
TypeScript is a **typed superset of JavaScript** that makes automation frameworks like Playwright **more reliable, maintainable, and developer-friendly**.

# **Before we learn we need to know the some of concepts**.

# why did Node.js come to the market in the first place? What problem did it solve?

## **The Background Before Node.js**

Before 2009 (when Node.js was introduced by Ryan Dahl), most web development looked like this:

* **JavaScript only ran in browsers** (for UI interactions).
    
* Server-side code was written in other languages like PHP, Java, Ruby, or .NET.
    
* Each client request was handled in a **blocking, multi-threaded** way â€” meaning each connection consumed a thread on the server.
    

This caused:

* **High memory consumption** with many connections.
    
* Poor scalability for real-time apps (e.g., chat, gaming, streaming).
    

---

## **Why Node.js Came to Market**

### **1\. To Use JavaScript on the Server**

* Until then, JavaScript was only client-side.
    
* Node.js brought **JavaScript to the backend**, enabling full-stack development with a single language.
    

---

### **2\. Non-blocking, Event-Driven Architecture**

* Traditional servers (like Apache with PHP) used **blocking I/O**: one thread waits for tasks (file read, database query) to complete.
    
* Node.js introduced **non-blocking I/O with an event loop**.
    
* This meant:
    
    * One thread can handle thousands of concurrent requests.
        
    * Great for **real-time apps (chat apps, streaming, APIs)**.
        

---

### **3\. High Performance with V8 Engine**

* Built on **Google Chrome's V8 engine**, Node.js executes JavaScript extremely fast.
    
* Compiles JS into machine code.
    

---

### **4\. Scalability and Lightweight**

* Uses **asynchronous callbacks, promises, async/await**.
    
* Runs on a **single-threaded event loop**, consuming fewer resources than multi-threaded servers.
    

---

### **5\. Huge Ecosystem (npm)**

* Node.js brought **npm (Node Package Manager)**, the worldâ€™s largest open-source library ecosystem.
    
* Made it easy to install, share, and update packages.
    

---

### **6\. Ideal for Modern Web Apps**

* Real-time chat (WhatsApp Web, Slack)
    
* Streaming services (Netflix, YouTube backend components)
    
* Microservices & APIs
    
* Automation tools (Playwright, Cypress)
    

---

## **In Simple Words**

Node.js came to the market to:

* **Break the wall between frontend and backend** (one language: JavaScript)
    
* **Handle high-concurrency applications efficiently**
    
* **Speed up development with a giant package ecosystem**
    
* **Enable real-time and scalable applications**
    

---

## **Analogy**

Old servers = Waiters who serve one table at a time (blocking).  
Node.js = A smart waiter who takes many orders, delivers them as theyâ€™re ready, and never waits idly.

## What is Node Package Manager (npm) is, how it came to exist, and Why it became essential for Node.js and the JavaScript ecosystem.

## **What is npm (Node Package Manager)?**

* **npm** is the default package manager for Node.js.
    
* It allows you to **install, share, manage, and update code packages (libraries, tools, frameworks)**.
    
* It comes bundled with Node.js (no need to install separately).
    

### **What Does npm Do?**

* Installs libraries like Express, React, Playwright, etc.
    
* Manages dependencies in your project via `package.json`.
    
* Allows you to publish your own packages.
    
* Provides access to the **worldâ€™s largest open-source library ecosystem**.
    

---

## **How Did npm Come? (The History)**

### **Before npm**

* JavaScript was mostly used in browsers.
    
* Developers relied on manually downloading libraries and linking them with `<script>` tags.
    
* Dependency management was a nightmare:
    
    * No central repository
        
    * Version conflicts (different libraries requiring different versions)
        
    * No standard way to share packages
        

### **The Birth of npm**

* **Created in 2010 by Isaac Z. Schlueter**, shortly after Node.js (2009).
    
* Built to solve:
    
    * **Package sharing** for Node.js
        
    * **Dependency management** in one place
        
    * **Version control** for libraries
        

### **npm's Growth**

* Quickly became the **standard package manager for Node.js**.
    
* Expanded to support frontend tools (React, Angular, Vue, TypeScript, Webpack).
    
* Now used not only in Node.js apps but also for automation, CI/CD, and even Python/.NET integrations.
    

---

## **How npm Works?**

1. You create a project:
    
    ```bash
    npm init -y
    ```
    
    â†’ Creates `package.json` (tracks dependencies and project metadata).
    
2. Install a package:
    
    ```bash
    npm install express
    ```
    
    â†’ Downloads package to `node_modules/` and updates `package.json`.
    
3. Use it in your code:
    
    ```javascript
    const express = require('express');
    ```
    
4. Update or remove packages easily:
    
    ```bash
    npm update
    npm uninstall express
    ```
    
5. Publish your own library:
    
    ```bash
    npm publish
    ```
    

---

## **Why npm is Important ?**

* Makes Node.js scalable and developer-friendly.
    
* Encourages code reuse (no need to rewrite common modules).
    
* Powers tools like Playwright, Selenium WebDriver JS, ESLint, TypeScript, etc.
    
* Became the **largest package ecosystem in the world (2M+ packages)**.
    

---

## **Alternatives to npm ?**

* **Yarn** (Facebookâ€™s alternative, faster installs, better caching).
    
* **pnpm** (space-efficient, symlink-based).
    
* **Bun** (modern, ultra-fast).
    

But npm remains the default and most widely supported.

## **1\. npm Workflow (Step by Step with Diagram)**

Hereâ€™s how npm works in a typical Node.js project:

```java
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Install Node.js     â”‚
 â”‚ (npm comes with it) â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Initialize Project  â”‚
 â”‚ npm init -y         â”‚
 â”‚ â†’ creates package.jsonâ”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Install Packages    â”‚
 â”‚ npm install <pkg>   â”‚
 â”‚ â†’ node_modules/     â”‚
 â”‚ â†’ package-lock.json â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Use in Code         â”‚
 â”‚ require()/import    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Update/Remove       â”‚
 â”‚ npm update / uninstallâ”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Share Your Project  â”‚
 â”‚ via package.json    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Publish Your Packageâ”‚
 â”‚ npm publish         â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## **2\. Key npm Commands (Automation & Testing Focus)**

### **Project Setup**

* `npm init -y` â†’ Creates a default `package.json`
    
* `npm install` â†’ Installs all dependencies listed in `package.json`
    

### **Installing Tools**

* Playwright:
    
    ```bash
    npm install -D @playwright/test
    npx playwright install
    ```
    
* Selenium WebDriver:
    
    ```bash
    npm install selenium-webdriver
    ```
    
* TypeScript:
    
    ```bash
    npm install -D typescript ts-node @types/node
    ```
    

### **Running Tests**

* Using Playwright:
    
    ```bash
    npx playwright test
    ```
    
* Using Selenium with Node:
    
    ```bash
    node your_test.js
    ```
    

### **Updating Dependencies**

* Update all:
    
    ```bash
    npm update
    ```
    
* Update a specific package:
    
    ```bash
    npm install <package>@latest
    ```
    

### **Other Important Commands**

* `npm list` â†’ View installed packages
    
* `npm outdated` â†’ Check for outdated packages
    
* `npm uninstall <package>` â†’ Remove a package
    
* `npm cache clean --force` â†’ Clear npm cache
    

---

## **3\. npm vs Maven (For Automation Testing)**

Youâ€™re already learning **Maven** for Java automation, so hereâ€™s a direct comparison:

| **Feature** | **npm (Node.js**) | **Maven (Java)** |
| --- | --- | --- |
| **Language Focus** | JavaScript/TypeScript | Java, Kotlin |
| **Dependency File** | `package.json` | `pom.xml` |
| **Package Repository** | npm registry (2M+ packages) | Maven Central (1M+ packages) |
| **Execution** | `npm run`, `npx` | `mvn clean install`, `mvn test` |
| **Build System** | No default build (Webpack, Rollup, etc.) | Built-in build lifecycle |
| **Test Integration** | Playwright, Jest, Mocha, Cypress | TestNG, JUnit, Selenium |
| **Usage in QA** | Web/API automation (Playwright, Cypress) | Web/API automation (Selenium, REST-Assured) |
| **Installation** | `npm install` (fast, lightweight) | `mvn install` (slower, XML heavy) |

### **When to Use npm in Automation?**

* Playwright, Cypress, Puppeteer automation
    
* API testing with Supertest or Axios
    
* TypeScript-based frameworks
    

### **When to Use Maven in Automation?**

* Selenium + Java/TestNG/JUnit projects
    
* RestAssured, Cucumber with Java
    
* Enterprise CI/CD pipelines using Java stack.
    
    # **Before leaening TypeScript or Playwright just UnderStand the below Topics.**
    

# ğŸ“˜ JavaScript Modules

---

## 1ï¸âƒ£ What Are Modules?

* A **module** is a file in JavaScript that **exports** variables, functions, or classes so they can be **imported** in another file.
    
* Modules help **organize code**, **avoid polluting global scope**, and **increase maintainability**.
    

**Example:**

```bash
// mathUtils.js
export function add(a, b) {
  return a + b;
}
export const PI = 3.14;

// main.js
import { add, PI } from './mathUtils.js';
console.log(add(5, 3)); // 8
console.log(PI);        // 3.14
```

âœ… Key points:

* Use `export` to make variables/functions/classes available outside the module.
    
* Use `import` to access exported content in another module.
    

---

## 2ï¸âƒ£ Types of Exports

### Named Export

```bash
// utils.js
export function greet(name) { return `Hello ${name}`; }
export const version = "1.0";

// app.js
import { greet, version } from './utils.js';
console.log(greet("Nini")); // Hello Nini
```

### Default Export

* A module can have **one default export**, which can be imported with any name.
    

```bash
// logger.js
export default function log(message) { console.log(message); }

// app.js
import logFunc from './logger.js';
logFunc("Test started"); // Test started
```

---

## 3ï¸âƒ£ Dynamic Import

* **Dynamic import** allows importing a module **at runtime**, not at the start.
    
* Returns a **Promise**, useful for **lazy loading modules**.
    

```bash
async function run() {
  const math = await import('./mathUtils.js');
  console.log(math.add(2, 3)); // 5
}
run();
```

âœ… Use cases:

* Load modules **only when needed** (performance optimization).
    
* Conditional module loading:
    

```javascript
if (condition) {
  const module = await import('./featureA.js');
  module.runFeature();
}
```

---

## 4ï¸âƒ£ Top-Level Await in Modules

* **Top-level await** allows using `await` **outside of async functions** at the top of a module.
    
* Only works **inside ES modules** (files with `.js` using `type: "module"` or `.mjs` files).
    

```javascript
// dataLoader.js
const response = await fetch('https://api.example.com/data');
const data = await response.json();
console.log(data);
```

âœ… Advantages:

* Makes async initialization simpler.
    
* Useful for loading configuration, test data, or setup before running automation tests.
    

---

## 5ï¸âƒ£ Using Modules in Node.js / Playwright

* In **Node.js / Playwright**, enable ES modules by:
    
    * Using `"type": "module"` in `package.json`
        
    * Or naming files `.mjs`
        

```json
// package.json
{
  "name": "playwright-project",
  "type": "module"
}
```

* Example in Playwright:
    

```javascript
// pageObjects/loginPage.js
export class LoginPage {
  constructor(page) { this.page = page; }
  async login(user, pass) {
    await this.page.fill('#username', user);
    await this.page.fill('#password', pass);
    await this.page.click('button[type=submit]');
  }
}

// tests/login.test.js
import { test } from '@playwright/test';
import { LoginPage } from '../pageObjects/loginPage.js';

test('login test', async ({ page }) => {
  const login = new LoginPage(page);
  await login.login('admin', '12345');
});
```

---

âœ… **Summary:**

* **Modules**: OrgağŸ“˜ JavaScript Modules
    
    ---
    
    ## 1ï¸âƒ£ What Are Modules?
    
    * A **module** is a file in JavaScript that **exports** variables, functions, or classes so they can be **imported** in another file.
        
    * Modules help **organize code**, **avoid polluting global scope**, and **increase maintainability**.
        
    
    **Example:**
    
    ```bash
    // mathUtils.js
    export function add(a, b) {
      return a + b;
    }
    export const PI = 3.14;
    
    // main.js
    import { add, PI } from './mathUtils.js';
    console.log(add(5, 3)); // 8
    console.log(PI);        // 3.14
    ```
    
    âœ… Key points:
    
    * Use `export` to make variables/functions/classes available outside the module.
        
    * Use `import` to access exported content in another module.
        
    
    ---
    
    ## 2ï¸âƒ£ Types of Exports
    
    ### Named Export
    
    ```javascript
    // utils.js
    export function greet(name) { return `Hello ${name}`; }
    export const version = "1.0";
    
    // app.js
    import { greet, version } from './utils.js';
    console.log(greet("Nini")); // Hello Nini
    ```
    
    ### Default Export
    
    * A module can have **one default export**, which can be imported with any name.
        
    
    ```javascript
    // logger.js
    export default function log(message) { console.log(message); }
    
    // app.js
    import logFunc from './logger.js';
    logFunc("Test started"); // Test started
    ```
    
    ---
    
    ## 3ï¸âƒ£ Dynamic Import
    
    * **Dynamic import** allows importing a module **at runtime**, not at the start.
        
    * Returns a **Promise**, useful for **lazy loading modules**.
        
    
    ```javascript
    async function run() {
      const math = await import('./mathUtils.js');
      console.log(math.add(2, 3)); // 5
    }
    run();
    ```
    
    âœ… Use cases:
    
    * Load modules **only when needed** (performance optimization).
        
    * Conditional module loading:
        
    
    ```javascript
    if (condition) {
      const module = await import('./featureA.js');
      module.runFeature();
    }
    ```
    
    ---
    
    ## 4ï¸âƒ£ Top-Level Await in Modules
    
    * **Top-level await** allows using `await` **outside of async functions** at the top of a module.
        
    * Only works **inside ES modules** (files with `.js` using `type: "module"` or `.mjs` files).
        
    
    ```javascript
    // dataLoader.js
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
    ```
    
    âœ… Advantages:
    
    * Makes async initialization simpler.
        
    * Useful for loading configuration, test data, or setup before running automation tests.
        
    
    ---
    
    ## 5ï¸âƒ£ Using Modules in Node.js / Playwright
    
    * In **Node.js / Playwright**, enable ES modules by:
        
        * Using `"type": "module"` in `package.json`
            
        * Or naming files `.mjs`
            
    
    ```json
    // package.json
    {
      "name": "playwright-project",
      "type": "module"
    }
    ```
    
    * Example in Playwright:
        
    
    ```javascript
    // pageObjects/loginPage.js
    export class LoginPage {
      constructor(page) { this.page = page; }
      async login(user, pass) {
        await this.page.fill('#username', user);
        await this.page.fill('#password', pass);
        await this.page.click('button[type=submit]');
      }
    }
    
    // tests/login.test.js
    import { test } from '@playwright/test';
    import { LoginPage } from '../pageObjects/loginPage.js';
    
    test('login test', async ({ page }) => {
      const login = new LoginPage(page);
      await login.login('admin', '12345');
    });
    ```
    
    ---
    
    âœ… **Summary:**
    
    * **Modules**: Organize and export code.
        
    * **Dynamic Import**: Load modules at runtime.
        
    * **Top-level Await**: Use `await` outside async functions at the module top level.
        
    * **Playwright Use**: Modularize POMs, utilities, and test scripts using ES modules.nize and export code.
        
* **Dynamic Import**: Load modules at runtime.
    
* **Top-level Await**: Use `await` outside async functions at the module top level.
    
* **Playwright Use**: Modularize POMs, utilities, and test scripts using ES modules.
    

âœ… Letâ€™s compare **JavaScript/TypeScript modules, dynamic import, and top-level await** with **Java equivalents** so itâ€™s easy to relate.

---

## ğŸ“Š Comparison: JS Modules vs Java

| Feature | JavaScript / TypeScript | Java Equivalent | Example |
| --- | --- | --- | --- |
| **Modules / Imports** | `export` / `import` | `public class` + `import package.Class` | JS: |
| `js export class Login {} import { Login } from './Login.js';` |  |  |  |
| Java: |  |  |  |
| `java package pages; public class Login {} import pages.Login;` |  |  |  |
| **Named Export / Import** | Multiple exports per file | Multiple public classes or methods in packages | JS: |
| `export function add(){} export const PI=3.14;` |  |  |  |
| Java: |  |  |  |
| `public class MathUtils { public static final double PI=3.14; public static int add(int a,int b){return a+b;} }` |  |  |  |
| **Default Export** | One default export per module | Class itself as main exposed API | JS: |
| `export default class Logger{} import Logger from './Logger.js';` |  |  |  |
| Java: |  |  |  |
| `public class Logger {} // import pages.Logger;` |  |  |  |
| **Dynamic Import** | `import()` at runtime, returns Promise | Reflection or Class.forName() | JS: |
| `const module = await import('./math.js');` |  |  |  |
| Java: |  |  |  |
| `Class<?> clazz = Class.forName("pages.Login"); Object obj = clazz.getDeclaredConstructor().newInstance();` |  |  |  |
| **Top-level Await** | Can use `await` outside async function in module | Java doesnâ€™t allow await at top level; must use `main` or another async context | JS: |
| `const data = await fetch(url);` |  |  |  |
| Java: |  |  |  |
| `CompletableFuture<String> data = httpClient.sendAsync(request, BodyHandlers.ofString()); data.thenAccept(System.out::println);` |  |  |  |

---

### ğŸ”¹ Key Observations:

1. **Modules:** Both organize code; JS uses file-based exports, Java uses packages & public classes.
    
2. **Dynamic import:** JS supports runtime loading natively; Java requires reflection (`Class.forName`).
    
3. **Top-level await:** JS modules allow simpler async initialization; Java always needs an **async context** (like `CompletableFuture` or threads).
    

---

### âš¡ Example: Playwright-like Page Object

**JavaScript / TypeScript (Module + POM + Await):**

```javascript
// loginPage.js
export class LoginPage {
  constructor(page) { this.page = page; }
  async login(user, pass) {
    await this.page.fill('#username', user);
    await this.page.fill('#password', pass);
    await this.page.click('#submit');
  }
}

// test.js
import { LoginPage } from './loginPage.js';
const login = new LoginPage(page);
await login.login('admin', '12345');
```

**Java (Selenium Page Object):**

```java
// LoginPage.java
package pages;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.By;

public class LoginPage {
    WebDriver driver;
    public LoginPage(WebDriver driver) { this.driver = driver; }
    public void login(String user, String pass) {
        driver.findElement(By.id("username")).sendKeys(user);
        driver.findElement(By.id("password")).sendKeys(pass);
        driver.findElement(By.id("submit")).click();
    }
}

// LoginTest.java
import pages.LoginPage;
LoginPage login = new LoginPage(driver);
login.login("admin","12345");
```

âœ… As you can see:

* **Module import/export** in JS â‰ˆ **package + import** in Java.
    
* **Async / Await** in JS â‰ˆ **WebDriver waits / threads / CompletableFuture** in Java.
    
* Dynamic import in JS â‰ˆ Reflection in Java.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759252853515/0fdc346d-9cfa-41f0-ae49-f10936a0ee04.png align="center")

## Statically and Dynamically Type Language

## **Typing Concepts**

| Feature | Statically Typed Language | Dynamically Typed Language |
| --- | --- | --- |
| **Definition** | Variable types are known at **compile time**. | Variable types are determined at **runtime**. |
| **Type Checking** | Done during compilation. | Done during execution. |
| **Error Detection** | Many type-related errors are caught **before running the code**. | Type errors appear only when the code executes. |
| **Flexibility** | Less flexible, more strict. | More flexible, allows implicit type changes. |
| **Examples** | Java, TypeScript | JavaScript, Python |

---

## **2\. Comparison Using JS, TS, and Java**

### **JavaScript (Dynamically Typed)**

```javascript
let x = 10;    // x is number now
x = "Hello";   // x is now string, no error
console.log(x); // Output: Hello
```

* JS doesnâ€™t enforce types.
    
* A variable can change its type at any time.
    
* Errors like adding a string to a number are only found at runtime.
    

### **TypeScript (Statically Typed)**

```javascript
let x: number = 10;
x = "Hello"; // âŒ Error: Type 'string' is not assignable to type 'number'
```

* TS is statically typed (optional, but recommended).
    
* Types are checked at **compile time**.
    
* Helps catch errors early before running the code.
    
* You can also use `any` type for dynamic behavior:
    

```javascript
let y: any = 10;
y = "Hello"; // âœ… No error
```

### **Java (Statically Typed)**

```javascript
int x = 10;
x = "Hello"; // âŒ Compile-time error
```

* Java is strictly statically typed.
    
* You must declare the type of every variable.
    
* Errors are caught during compilation.
    

## **3\. Key Differences Between JS, TS, and Java**

| Feature | JavaScript | TypeScript | Java |
| --- | --- | --- | --- |
| Typing | Dynamic | Static (optional) | Static |
| Compilation | Interpreted | Compiled to JS | Compiled to bytecode |
| Type Safety | Low | High | Very High |
| Variable Reassignment | Any type | Must follow declared type | Must follow declared type |
| Error Detection | Runtime | Compile-time | Compile-time |
| Popular Use | Web | Web, Large-scale apps | Enterprise, Backend, Android |

### **Summary**

* **JS:** Flexible but prone to runtime errors.
    
* **TS:** Adds static typing to JS â†’ safer, easier to maintain.
    
* **Java:** Fully statically typed â†’ very strict, robust for large apps.
    

### **Type System Comparison Diagram**

```javascript
             +-------------------------+
             |      JavaScript         |
             |  Dynamically Typed      |
             |  Type checked at runtime|
             |  Flexible, but risky   |
             +-------------------------+
                        |
                        v
             +-------------------------+
             |      TypeScript         |
             |  Statically Typed       |
             |  Type checked at compile|
             |  Can catch errors early |
             |  Safer than JS          |
             +-------------------------+
                        |
                        v
             +-------------------------+
             |         Java            |
             |  Statically Typed       |
             |  Strict compile-time    |
             |  Very robust & safe     |
             +-------------------------+
```

---

### **Quick Example Table**

| Language | Variable Declaration | Type Checking | Example Error |
| --- | --- | --- | --- |
| JavaScript | `let x = 10;` | Runtime | `x = "Hello"; // ok at compile, fails at runtime if logic depends on number` |
| TypeScript | `let x: number = 10;` | Compile-time | `x = "Hello"; // âŒ Error at compile time` |
| Java | `int x = 10;` | Compile-time | `x = "Hello"; // âŒ Error at compile time` |

---

âœ… **Takeaway:**

* JS = flexible, runtime errors
    
* TS = JS + static type safety
    
* Java = strict static typing
    

# Lets study TypeScriptâ€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦

## Coomads need to know..

## **ğŸ“˜ Node.js Commands**

| Command | Description |
| --- | --- |
| `node -v` | Check Node.js version |
| `npm -v` | Check npm version |
| `npm init` | Initialize a new project (interactive) |
| `npm init -y` | Initialize a new project with default settings |
| `npm install <package>` | Install package locally |
| `npm install -g <package>` | Install package globally |
| `npm install --save <package>` | Add package to dependencies |
| `npm install --save-dev <package>` | Add package to devDependencies |
| `npm uninstall <package>` | Remove a package |
| `npm update <package>` | Update a package |
| `node app.js` | Run a JS file |
| `nodemon app.js` | Run with auto-reload (requires nodemon) |
| `npm start` | Run start script from package.json |
| `npm run <script>` | Run custom script from package.json |
| `npm list -g --depth=0` | List global packages |
| `npm outdated` | Check outdated packages |
| `node` | Start Node.js REPL (interactive console) |
| `node --inspect app.js` | Debug Node.js file using Chrome DevTools |
| `node --trace-warnings app.js` | Show runtime warnings |

---

## **ğŸ“˜ TypeScript Commands**

| Command | Description |
| --- | --- |
| `npm install -g typescript` | Install TypeScript globally |
| `tsc -v` | Check TypeScript version |
| `tsc --init` | Initialize a TypeScript project (`tsconfig.json`) |
| `tsc app.ts` | Compile a single TypeScript file to JavaScript |
| `tsc` | Compile project using `tsconfig.json` |
| `tsc -w` | Watch mode â€“ automatically compile on file changes |
| `tsc app.ts --target ES6` | Compile TS file targeting ES6 JS |
| `tsc app.ts --outDir ./dist` | Set output directory for compiled JS |
| `tsc app.ts --module commonjs` | Set module system |
| `ts-node app.ts` | Run TypeScript file directly without compiling (requires `ts-node`) |
| `tsc --listFiles` | List all files compiled by TypeScript |
| `tsc --diagnostics` | Show compilation statistics |
| `tsc --init --strict` | Create `tsconfig.json` with strict mode enabled |
| `tslint -c tslint.json 'src/**/*.ts'` | Lint TypeScript files (requires `tslint`) |
| `prettier --write "src/**/*.ts"` | Format TypeScript files (requires `prettier`) |

---

âœ… **Tip:**

* **Node.js commands** are mostly for runtime, package management, and debugging.
    
* **TypeScript commands** focus on compilation, type checking, and project configuration.
    

# **01 Introduction to TypeScript**

* TypeScript is a **superset of JavaScript** that adds **static types**.
    
* Compiles to plain JavaScript: `tsc filename.ts`
    
* Advantages:
    
    * Early error detection
        
    * Better IDE support (autocomplete, intellisense)
        
    * Large-scale app maintainability
        

# **02 TypeScript Setup**

The following tools you need to set up to start with TypeScript:

* **Visual Studio Code or VS Code** â€“ a code editor supporting TypeScript.
    
* **Node.js** â€“ Node.js is the environment in which you will run the TypeScript compiler.
    
* **TypeScript compiler** â€“ a Node.js module that compiles TypeScript into JavaScript.
    

If you use VS Code, you can install the following extension to speed up the development process:

* Live Server â€“ allows you to launch a development local web server with the hot reload feature.
    

## **Install Node.js**

**Install** node.js and open Command Prompt on Windows and type the command `node -v`, it should show the installed version of Node.js.

## **Install TypeScript compiler**

To install the TypeScript compiler, you launch the Terminal on macOS or Linux and Command Prompt on Windows and type the following command:

```bash
// global
npmÂ installÂ -gÂ typescript 
// or
// local (This keeps your project self-contained and avoids version mismatches.
npm install --save-dev typescript
```

After the installation, you can type the following command to check the current version of the TypeScript **tsc --v**

It should return the version like this: **Version 5.8.3**

## **Install tsx module**

If you want to run TypeScript code directly on Node.js without precompiling, you can use the `tsx` module.

## **Summary**

* A TypeScript compiler compiles the TypeScript into JavaScript.
    
* Use the `tsc` command to compile a TypeScript file to a JavaScript file.
    
* Use the `tsx` module to run TypeScript directly on Node.js without precompiling it to JavaScript.
    

# **03 TypeScript â€œHello, Nini!â€**

## **TypeScript Hello Nini program in Node.js**

* launch VS Code create a directory as **TypeScript** and inside create another child directoty as **TypeScript\_Tutorial** . and install all as \*\*local (\*\*This keeps the project self-contained and avoids version mismatches).
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759317474112/99f83038-486c-4f8c-9c18-b2b2197ebb84.png align="center")
    
    Inside **TypeScript\_Tutorial** project create a new directory as **HelloNini** and Inside **HelloNini-derectory** create a new TypeScript file called `app.ts`. The extension of a TypeScript file is `.ts`.
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759317867674/677c3615-b682-474b-ade5-d9ff11b5661f.png align="center")
    
    Here i have added another file as **README.md** file to give extra information about the project.
    
* And type the following source code in the `app.ts` file.
    
    ```typescript
    let message: string = 'Hello, Nini!';
    console.log(message);
    ```
    
    Right-Click on directoty and **open in integrated Terminal** to compile the **.ts** file .
    
* type the following command on the Terminal to compile the `tsc app.ts` and click **enter.**
    
* If everything is fine, youâ€™ll see a new file called `app.js` is generated by the TypeScript compiler.
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759318745101/20e10e14-3032-4d05-9141-3ffa25aafde1.png align="center")
    
    To run the `app.js` file in `Node.js`, type following command in same directory `node app.js` and Click on Enter.
    
* If everything is fine, it will show the output in console.
    
    **OUTPUT:**
    
    ```bash
    hp@NINI MINGW64 /TypeScript/TypeScript_Tutorial/HelloNini (main)
    $ node app.js
    Hello, Nini!
    ```
    

If you installed the `tsx` module you can use just one command to run the TypeScript file directly on Node.js without precompiling it to JavaScript:

```bash
tsx app.ts
```

# **04 Why TypeScript ?**

## **Why use TypeScript**

There are two main reasons to use TypeScript:

* TypeScript adds a type system to help you avoid many problems with dynamic types in JavaScript.
    
* TypeScript implements the future ***features*** of JavaScript **ES Next** so you can use them today.
    

**This tutorial focuses on the first reason.**

## **Understanding dynamic type in JavaScript**

JavaScript is dynamically typed. Unlike statically typed languages such as Java or C#, **values have types instead of variables**.

**JavaScript is dynamically typed**. Let me explain with a clear example.

---

## ğŸ”¹ In JavaScript (Dynamically Typed)

* **Variables donâ€™t have fixed types**.
    
* The **value** determines the type, not the variable.
    
* You can reassign different types to the same variable.
    

âœ… Example:

```javascript
let value = 42;          // number
console.log(typeof value); // "number"

value = "hello";         // âœ… allowed, now it's a string
console.log(typeof value); // "string"

value = true;            // âœ… allowed, now it's a boolean
console.log(typeof value); // "boolean"
```

ğŸ‘‰ Here, **value** of **variable** keeps changing **type** depending on the value.

ğŸ‘‰ **Variables** donâ€™t have a fixed **type**, only the **value** has a type.

---

## ğŸ”¹ In Java / C# (Statically Typed)

* **Variables have fixed types**.
    
* Once declared, you cannot assign a different type.
    

âœ… Java Example:

```java
public class Main {
    public static void main(String[] args) {
        int value = 42;      // int type fixed
        System.out.println(value);

        // value = "hello";  // âŒ ERROR: incompatible types
        // value = true;     // âŒ ERROR: cannot convert boolean to int
    }
}
```

ğŸ‘‰Variables **must have a type** and it **cannot change**.

---

## ğŸ“Š Key Difference

| **Feature** | **JavaScript** (Dynamic) | **Java**/**C#** (Static) |
| --- | --- | --- |
| Type Binding | At runtime | At compile-time |
| Variable has type? | âŒ No, value has type | âœ… Yes, variable fixed type |
| Flexibility | High (can reassign) | Low (strict typing) |
| Error detection | At runtime | At compile-time |

---

## ğŸ”¹ TypeScript (Static Typing on top of JavaScript)

```typescript
let value: number = 42;  
console.log(value);

value = "hello";   // âŒ ERROR: Type 'string' is not assignable to type 'number'
value = true;      // âŒ ERROR: Type 'boolean' is not assignable to type 'number'
```

ğŸ‘‰ TypeScript works like Java in terms of typing but **still compiles to JavaScript**.

âœ… This is why TypeScript was created â†’ to add **static typing** to JavaScript for better safety. we called it **typeSafety**.

## ğŸ“Š Quick Comparison

| Feature | JavaScript | Java | TypeScript |
| --- | --- | --- | --- |
| Typing | Dynamic (runtime) | Static (compile-time) | Static (compile-time, but compiles to JS) |
| Variable type fixed? | âŒ No | âœ… Yes | âœ… Yes |
| Flexibility | High | Low | Medium (strict, but allows `any`) |
| Example behavior | Same variable can be number â†’ string â†’ boolean | Not allowed | Not allowed |

---

âš¡ **Summary:**

* JavaScript â†’ variables can hold any type, changes at runtime.
    
* Java â†’ variable type fixed at compile time.
    
* TypeScript â†’ adds Java-like strict typing to JavaScript.
    

# **04 TypeScript Types**

## ğŸ”¹ What is a Type in TypeScript?

A **type** in TypeScript is a way to describe the **shape** or **kind of data** a variable, parameter, or function can hold.

* It tells the compiler **what kind of values** are allowed.
    
* Example:
    
    ```javascript
    let age: number = 25;   // type: number
    let name: string = "Nini"; // type: string
    let isAdmin: boolean = true; // type: boolean
    ```
    

ğŸ‘‰ In short: A **type is like a contract** that ensures variables and functions are used correctly.

---

## ğŸ”¹ Types in TypeScript

Types are broadly categorized into **two groups**:

### 1\. **Primitive Types**

Basic building blocks (same as in Java/JavaScript but with strict typing).

* `number` â†’ integers, floats, etc.
    
* `string` â†’ text values
    
* `boolean` â†’ true/false
    
* `null`
    
* `undefined`
    
* `bigint` â†’ very large numbers
    
* `symbol` â†’ unique identifiers
    

âœ… Example:

```javascript
let count: number = 10;
let username: string = "Nini";
let loggedIn: boolean = false;
```

---

### 2\. **Special & Advanced Types**

* `any` â†’ can hold **anything** (least safe).
    
* `unknown` â†’ safer alternative to `any` (must check before using).
    
* `void` â†’ function doesnâ€™t return anything.
    
* `never` â†’ function never returns (e.g., throws error).
    
* `object` â†’ non-primitive values.
    
* `array` â†’ list of elements (`number[]`, `string[]`).
    
* `tuple` â†’ fixed-size array with known types.
    
* `enum` â†’ named constants.
    
* **Custom types** â†’ `type` and `interface`.
    

âœ… Example:

```javascript
let data: any = 42; // can be number, string, etc.
let values: number[] = [1, 2, 3];
let tupleEx: [string, number] = ["Age", 25];

enum Role { Admin, User, Guest }
let role: Role = Role.Admin;
```

---

## ğŸ”¹ **Purposes of types in TypeScript**

There are two main purposes of types in TypeScript:

* First, types are used by the TypeScript compiler to analyze your code for **errors**.
    
* Second, types allow you to understand what values are associated with variables.
    

1. **Error Prevention (Safety)**
    
    * Catches mistakes at compile time (before running).
        
    
    ```javascript
    let age: number = 25;
    age = "twenty-five"; // âŒ ERROR
    ```
    
2. **Readability & Documentation**
    
    * Makes code easier to understand.
        
    
    ```javascript
    function greet(name: string): string {
      return "Hello, " + name;
    }
    ```
    
    **Other Purpose are :**
    
    **IntelliSense & Autocomplete**
    
    * Editors (like VS Code) can suggest methods and properties.
        
    
    **Scalability**
    
    * Large teams/projects benefit from predictable types.
        
    
    **Better Refactoring**
    
    * Changing a type propagates errors/warnings across the codebase, helping avoid bugs.
        

---

## ğŸ“Š Quick Summary

| Feature | Description |
| --- | --- |
| **Type** | Defines what kind of data a variable/function can hold |
| **Types in TS** | Primitive (number, string, boolean, etc.), Special (`any`, `void`, `never`), Advanced (`array`, `tuple`, `enum`, `interface`, `type`) |
| **Purpose** | Safety, readability, better tooling (IntelliSense), scalability, refactoring |

ğŸ‘ **TypeScript Types Cheatsheet** ğŸ“’ â€” with categories, definitions, and examples for quick reference.

---

## ğŸ“˜ TypeScript Types Cheatsheet

## ğŸ”¹ 1. Primitive Types

| Type | Description | Example |
| --- | --- | --- |
| `number` | Numeric values (int, float, hex, binary) | `let age: number = 25;` |
| `string` | Text values | `let name: string = "Nini";` |
| `boolean` | True/False | `let isAdmin: boolean = true;` |
| `null` | Null value | `let x: null = null;` |
| `undefined` | Undefined value | `let y: undefined = undefined;` |
| `bigint` | Very large integers | `let big: bigint = 9007199254740991n;` |
| `symbol` | Unique identifier | `let sym: symbol = Symbol("id");` |

## ğŸ”¹ 2. Special Types

| Type | Description | Example |
| --- | --- | --- |
| `any` | Can be **anything** (disables type checking) | `let data: any = "text"; data = 123;` |
| `unknown` | Like `any` but safer (must check type first) | `let val: unknown = "hi"; if (typeof val === "string") console.log(val.toUpperCase());` |
| `void` | No return value (usually for functions) | `function log(msg: string): void { console.log(msg); }` |
| `never` | Function never returns (infinite loop or error) | `function fail(): never { throw new Error("Error!"); }` |
| `object` | Any non-primitive object | `let obj: object = {name: "Nini"};` |

## ğŸ”¹ 3. Structured Types

| Type | Description | Example |
| --- | --- | --- |
| `array` | Collection of same type | `let nums: number[] = [1, 2, 3];` |
| `tuple` | Fixed-size array with specific types | `let tupleEx: [string, number] = ["Age", 25];` |
| `enum` | Named constants | `enum Role { Admin, User, Guest } let r: Role = Role.Admin;` |

## ğŸ”¹ 4. Function Types

| Type | Description | Example |
| --- | --- | --- |
| Function parameters & return | Explicit typing of arguments and return value | `function add(a: number, b: number): number { return a + b; }` |
| Optional parameter | Parameter may or may not be provided | \`function greet(name?: string) { return "Hi " + (name |
| Default parameter | Has a default value | `function greet(name: string = "Guest") { return "Hi " + name; }` |

## ğŸ”¹ 5. Advanced Types

| Type | Description | Example |
| --- | --- | --- |
| `union` | Multiple possible types | \`let id: number |
| `intersection` | Combine multiple types | `type A = {x: number}; type B = {y: string}; let obj: A & B = {x: 1, y: "hi"};` |
| `type alias` | Custom name for a type | \`type ID = number |
| `interface` | Structure for objects/classes | `interface User { id: number; name: string; } let u: User = {id: 1, name: "Nini"};` |
| `literal` | Specific allowed values | \`let status: "success" |
| `generics` | Reusable type placeholders | `function identity<T>(arg: T): T { return arg; } let output = identity<string>("Hello");` |

# **05 Type Annotations**

## ğŸ”¹ What is Type Annotation in TypeScript?

**Type annotation** is when you explicitly **declare the type** of a **variable**, **constant**, **function parameter**, or **return type**.

* It tells the compiler: â€œThis **variable** should **only** hold values of this type.â€
    
* TypeScript will throw an error if you try to assign a value of a different type.
    

Syntax:

```typescript
let variableName: type = value;
```

---

## ğŸ”¹ Type Annotations in Variables and Constants

### 1\. Variables

```typescript
let age: number = 25;          // number type
let name: string = "Nini";     // string type
let isAdmin: boolean = true;   // boolean type
```

### 2\. Constants

```typescript
const userName: string = "Nini"; // string constant
const pi: number = 3.14;         // number constant
```

> âš¡ Note: Constants with `const` must be initialized when declared.

---

## ğŸ”¹ Type Annotation Examples

### 1\. Arrays

```typescript
let numbers: number[] = [1, 2, 3];
let names: string[] = ["Nini", "Alice"];
```

### 2\. Tuples

```typescript
let user: [string, number] = ["Nini", 25]; // fixed-size: name + age
```

### 3\. Functions

```typescript
function greet(name: string): string {
    return "Hello, " + name;
}

console.log(greet("Nini"));
```

### 4\. Objects

```typescript
let person: { name: string; age: number; isAdmin: boolean } = {
    name: "Nini",
    age: 25,
    isAdmin: true
};
```

### 5\. Union Types

```typescript
let id: number | string;
id = 101;
id = "Nini123";
```

### 6\. Any / Unknown

```typescript
let data: any = 42;
data = "Nini";   // âœ… allowed

let unknownData: unknown = "Nini";
// unknownData.toUpperCase(); âŒ ERROR: Type must be checked first
if (typeof unknownData === "string") {
    console.log(unknownData.toUpperCase()); // âœ… safe
}
```

---

## ğŸ”¹ Summary

| Feature | Example |
| --- | --- |
| Variable Annotation | `let name: string = "Nini";` |
| Constant Annotation | `const userName: string = "Nini";` |
| Array Annotation | `let names: string[] = ["Nini"];` |
| Tuple | `let user: [string, number] = ["Nini", 25];` |
| Object Annotation | `let person: { name: string; age: number } = { name: "Nini", age: 25 };` |
| Function Parameter & Return | `function greet(name: string): string { return "Hello, " + name; }` |
| Union Type | \`let id: number |
| Any / Unknown | `let data: any = "Nini";` |

# **06 Type Inference**

## ğŸ”¹ 1. Basic Type Inference

**Type inference** is when TypeScript **automatically determines the type** of a variable based on its value, without an explicit type annotation.

âœ… Example:

```typescript
let name = "Nini";    // TypeScript infers type as string
let age = 25;         // inferred as number
let isAdmin = true;   // inferred as boolean
```

> You donâ€™t need to write `:string` or `:number` here.  
> TypeScript guesses the type from the assigned value.

---

## ğŸ”¹ 2. The Best Common Type Algorithm

* TypeScript tries to **find a single type that works for multiple values**.
    
* If values have **different types**, TypeScript tries to pick a **common type**.
    

âœ… Example:

```typescript
let arr = ["Nini", "Alice", "Bob"]; // inferred as string[]
let mixed = [1, 2, "Nini"];         // inferred as (string | number)[]
```

> TypeScript looks at all elements and picks the **best common type** that fits all values.

---

## ğŸ”¹ 3. Contextual Typing

* TypeScript can **infer types from context**, like function parameters or object properties.
    
* The type is **not explicit**, but TypeScript knows it based on where the value is used.
    

âœ… Example:

```typescript
window.onmousedown = function(event) {
    console.log(event.button); // event is inferred as MouseEvent
};

let greet: (name: string) => string = function(n) {
    return "Hello, " + n;
};
console.log(greet("Nini"));
```

> The compiler infers `event` and `n` types from context.

---

## ğŸ”¹ 4. Type Inference vs Type Annotations

| Feature | Type Inference | Type Annotation |
| --- | --- | --- |
| Explicitly written? | âŒ No | âœ… Yes |
| Compiler assigns type? | âœ… Yes, automatically | âŒ You specify it |
| Example | `let age = 25; // inferred as number` | `let age: number = 25;` |
| Use Case | Quick, safe for simple cases | Needed for complex types, clarity, or API contracts |
| Flexibility | Less typing, but still safe | Guarantees exact type, prevents mistakes |

---

## ğŸ”¹ 5. Summary

* **Type Inference** â†’ TypeScript guesses the type based on value or context.
    
* **Best Common Type Algorithm** â†’ Picks a type that fits all elements in arrays or unions.
    
* **Contextual Typing** â†’ Type inferred based on usage (like parameters or events).
    
* **Type Inference vs Type Annotation** â†’ Inference = automatic, Annotation = explicit.
    

âœ… Example combining everything:

```typescript
let name = "Nini";                    // inferred string
let mixed: (string | number)[] = [1, "Nini"]; // explicit union type
function greet(n: string) {           // type annotation
    console.log("Hello, " + n);
}
let clickHandler = (event) => {       // contextual typing
    console.log(event.button);
};
```

# 07 Control Flow Statements in TypeScript ğŸš¦

## 1ï¸âƒ£ Conditional Statements â“

### a) `if` / `else if` / `else`

```typescript
let age: number = 20;

if (age >= 18) {
    console.log("ğŸ‰ Nini is an adult!");
} else if (age > 12) {
    console.log("ğŸ‘¦ Nini is a teenager");
} else {
    console.log("ğŸ¼ Nini is a child");
}
```

### b) Ternary Operator `? :` âš¡

```typescript
let isAdmin: boolean = true;
console.log(isAdmin ? "ğŸ›¡ï¸ Nini is admin" : "ğŸ‘¤ Nini is user");
```

### c) `switch` statement ğŸ”„

```typescript
let role: string = "Admin";

switch (role) {
    case "Admin":
        console.log("ğŸ›¡ï¸ Nini can manage users");
        break;
    case "User":
        console.log("ğŸ‘¤ Nini can view content");
        break;
    case "Guest":
        console.log("ğŸ‘» Nini has limited access");
        break;
    default:
        console.log("âŒ Role not recognized");
}
```

---

## 2ï¸âƒ£ Loops ğŸ”

### a) `for` loop ğŸ”„

```typescript
let names: string[] = ["Nini", "Alice", "Bob"];
for (let i = 0; i < names.length; i++) {
    console.log("ğŸ‘‹ Hello " + names[i]);
}
```

### b) `for...of` loop âœ¨ (ES6 style)

```typescript
for (let name of names) {
    console.log("ğŸ‘‹ Hello " + name);
}
```

### c) `for...in` loop ğŸ”‘ (for object keys)

```typescript
let person = { name: "Nini", age: 25, isAdmin: true };
for (let key in person) {
    console.log(`${key} => ${person[key as keyof typeof person]}`);
}
```

### d) `while` loop â³

```typescript
let count = 3;
while (count > 0) {
    console.log("â³ Countdown: " + count);
    count--;
}
```

### e) `do...while` loop ğŸŒ€

```typescript
let num = 1;
do {
    console.log("ğŸŒ€ Num is " + num);
    num++;
} while (num <= 3);
```

---

## 3ï¸âƒ£ Jump Statements ğŸš€

* `break` â†’ Exit a loop early
    
* `continue` â†’ Skip current iteration
    
* `return` â†’ Exit a function
    
* `throw` â†’ Raise an error
    

âœ… Example:

```typescript
for (let i = 1; i <= 5; i++) {
    if (i === 3) continue; // skip 3
    if (i === 5) break;    // stop at 5
    console.log("Loop i =", i);
}

function greet(name: string): void {
    if (!name) throw new Error("âŒ Name required");
    console.log("Hello, " + name);
}

greet("Nini");
```

---

## 4ï¸âƒ£ Summary Table ğŸ“Š

| Type | Example | Emoji Hint |
| --- | --- | --- |
| `if / else if / else` | Conditional branching | â“ |
| Ternary `? :` | Short if-else | âš¡ |
| `switch` | Multi-choice branching | ğŸ”„ |
| `for` | Classic loop | ğŸ” |
| `for...of` | Array/iterable loop | âœ¨ |
| `for...in` | Object keys loop | ğŸ”‘ |
| `while` | Pre-check loop | â³ |
| `do...while` | Post-check loop | ğŸŒ€ |
| `break` | Exit loop | ğŸšª |
| `continue` | Skip iteration | â­ï¸ |
| `return` | Exit function | ğŸ |
| `throw` | Error | âŒ |

# **08 TypeScript Functions**

## ğŸ”¹ 1. Introduction to TypeScript Functions ğŸ”¹

Functions are **blocks of code** designed to perform a specific task.  
TypeScript adds **type safety** to JavaScript functions by allowing you to **define types for parameters and return values**.

### âœ… Basic Function Syntax

```typescript
function greet(name: string): string {
    return "Hello, " + name + " ğŸ‘‹";
}

console.log(greet("Nini")); // Output: Hello, Nini ğŸ‘‹
```

* `name: string` â†’ Parameter type annotation
    
* `: string` after parentheses â†’ Return type annotation
    

---

### ğŸ”¹ Features of TypeScript Functions

1. **Typed Parameters** â€“ ensures correct argument types
    
2. **Typed Return Values** â€“ ensures function returns correct type
    
3. **Optional Parameters** â€“ marked with `?`
    
4. **Default Parameters** â€“ assign default values
    
5. **Rest Parameters** â€“ gather multiple arguments into an array
    
6. **Function Types** â€“ describe functions as types
    

---

## ğŸ”¹ 2. TypeScript Function Types

Function types **describe the signature of a function** â€” the types of its parameters and return type.

### 1ï¸âƒ£ Example: Basic Function Type

```typescript
let greetFn: (name: string) => string;

greetFn = function(name: string): string {
    return "Hello, " + name;
};

console.log(greetFn("Nini"));
```

> `(name: string) => string` â†’ function type: takes a string, returns a string

---

### 2ï¸âƒ£ Optional Parameters `?`

```typescript
function greetOptional(name?: string): string {
    return "Hello, " + (name || "Nini");
}

console.log(greetOptional());      // Hello, Nini
console.log(greetOptional("Alice")); // Hello, Alice
```

---

### 3ï¸âƒ£ Default Parameters

```typescript
function greetDefault(name: string = "Nini"): string {
    return "Hello, " + name;
}

console.log(greetDefault());       // Hello, Nini
console.log(greetDefault("Alice")); // Hello, Alice
```

---

### 4ï¸âƒ£ Rest Parameters `...args`

```typescript
function greetAll(...names: string[]): string {
    return "Hello, " + names.join(", ");
}

console.log(greetAll("Nini", "Alice", "Bob")); // Hello, Nini, Alice, Bob
```

---

### 5ï¸âƒ£ Void Functions

* Functions that **donâ€™t return anything** use `void`.
    

```typescript
function sayHi(name: string): void {
    console.log("Hi, " + name);
}

sayHi("Nini"); // prints Hi, Nini
```

---

### 6ï¸âƒ£ Function Types as Aliases

```typescript
type GreetFn = (name: string) => string;

let greetUser: GreetFn = (name) => "Hello, " + name;

console.log(greetUser("Nini"));
```

---

## ğŸ”¹ Summary Table ğŸ“Š

| Feature | Syntax | Example |
| --- | --- | --- |
| Typed Parameters | `(param: type)` | `name: string` |
| Typed Return | `(): type` | `(): string` |
| Optional Parameter | `param?: type` | `name?: string` |
| Default Parameter | `param: type = value` | `name: string = "Nini"` |
| Rest Parameter | `...param: type[]` | `...names: string[]` |
| Void Function | `(): void` | `function sayHi(): void { ... }` |
| Function Type | `(param: type) => type` | `(name: string) => string` |
| Function Type Alias | `type Fn = (param) => type` | `type GreetFn = (name: string) => string` |

---

âœ… **Key Takeaways:**

* TypeScript functions enforce **type safety** for parameters and return values.
    
* Use **optional/default/rest parameters** for flexibility.
    
* **Function types** help describe functions as first-class citizens.
    

## ğŸ”¹3. Function Overloading in TypeScript ğŸ”¹

**Function overloading** allows a single function to have **multiple signatures** â€” different ways it can be called â€” **with different parameter types or counts**, but with **one implementation**.

* TypeScript uses **function signatures** to define the overloads.
    
* Only **one actual implementation** is written.
    

---

## ğŸ”¹ Syntax

```typescript
function functionName(param: type1): returnType;
function functionName(param: type2): returnType;
function functionName(param: any): any {
    // implementation
}
```

> The first lines are **overload signatures**. The last function is the **implementation**.

---

## ğŸ”¹ Example 1: Simple Overloading

```typescript
// Overload signatures
function greet(name: string): string;
function greet(name: string, age: number): string;

// Implementation
function greet(name: string, age?: number): string {
    if (age !== undefined) {
        return `Hello, ${name} ğŸ‘‹, Age: ${age}`;
    } else {
        return `Hello, ${name} ğŸ‘‹`;
    }
}

// Usage
console.log(greet("Nini"));         // Hello, Nini ğŸ‘‹
console.log(greet("Nini", 25));     // Hello, Nini ğŸ‘‹, Age: 25
```

âœ… Notes:

* `age` is optional in the implementation.
    
* Signatures define **allowed ways to call the function**.
    

---

## ğŸ”¹ Example 2: Overloading with Different Types

```typescript
// Overload signatures
function combine(a: string, b: string): string;
function combine(a: number, b: number): number;

// Implementation
function combine(a: any, b: any): any {
    return a + b;
}

// Usage
console.log(combine("Nini", " Rocks"));  // "Nini Rocks"
console.log(combine(10, 20));            // 30
```

âœ… Notes:

* The implementation uses `any` type to cover all cases.
    
* Overload signatures restrict how users can call the function.
    

---

## ğŸ”¹ Why Use Function Overloading?

1. **Flexibility** â€“ Same function name, multiple behaviors
    
2. **Type Safety** â€“ TypeScript ensures correct usage based on signatures
    
3. **Readability** â€“ Clear documentation for function usage
    

---

## ğŸ”¹ Summary Table ğŸ“Š

| Concept | Example | Notes |
| --- | --- | --- |
| Single parameter | `greet(name: string)` | Basic function call |
| Multiple parameters | `greet(name: string, age: number)` | Optional in implementation |
| Different types | `combine(a: string, b: string)` or `(a: number, b: number)` | Overloaded function signatures |
| Implementation | `function greet(name: string, age?: number)` | Only **one actual function body** |

---

âœ… **Key Takeaways:**

* Overload **signatures** define allowed calls.
    
* Only **one implementation** exists.
    
* Makes functions **flexible and type-safe**.
    

# **09 TypeScript Class Interface**

## ğŸ”¹ 1. Introduction to TypeScript Classes ğŸ«

* A **class** is a blueprint for creating objects with **properties (data)** and **methods (functions)**.
    
* TypeScript classes are similar to **Java/C# classes** but compile to **JavaScript ES5/ES6 classes**.
    
* Supports **OOP concepts**: encapsulation, inheritance, abstraction, and polymorphism.
    

---

## ğŸ”¹ 2. Basic Class Syntax

```typescript
class Person {
    name: string;    // property
    age: number;     // property

    constructor(name: string, age: number) { // constructor
        this.name = name;
        this.age = age;
    }

    greet(): string {   // method
        return `Hello, ${this.name} ğŸ‘‹`;
    }
}

// Create object
let nini = new Person("Nini", 25);
console.log(nini.greet()); // Hello, Nini ğŸ‘‹
```

âœ… Notes:

* `constructor` â†’ initializes object properties
    
* `this` â†’ refers to the current instance
    

---

## ğŸ”¹ 3. Access Modifiers ğŸ”

TypeScript supports **access modifiers** like Java:

| Modifier | Visibility | Example |
| --- | --- | --- |
| `public` | Anywhere | default, accessible outside class |
| `private` | Only inside class | cannot access outside |
| `protected` | Class & subclasses | accessible in class and derived class |

### Example:

```typescript
class Person {
    public name: string;
    private ssn: string;
    protected age: number;

    constructor(name: string, ssn: string, age: number) {
        this.name = name;
        this.ssn = ssn;
        this.age = age;
    }

    showSSN() {
        return `SSN: ${this.ssn}`;
    }
}

let nini = new Person("Nini", "123-45-6789", 25);
console.log(nini.name);       // âœ… Nini
// console.log(nini.ssn);     // âŒ Error: private
// console.log(nini.age);     // âŒ Error: protected
console.log(nini.showSSN());  // âœ… SSN: 123-45-6789
```

---

## ğŸ”¹ 4. Readonly Properties ğŸ“

* `readonly` â†’ can be assigned **only once** (during declaration or in constructor).
    

```typescript
class Person {
    readonly name: string;

    constructor(name: string) {
        this.name = name;
    }
}

let nini = new Person("Nini");
// nini.name = "Alice"; // âŒ Error: readonly
```

---

## ğŸ”¹ 5. Parameter Properties (Shortcut) âš¡

* You can declare **properties directly in constructor parameters** using access modifiers.
    

```typescript
class Person {
    constructor(public name: string, private age: number) {}

    greet() {
        return `Hello, ${this.name} ğŸ‘‹`;
    }
}

let nini = new Person("Nini", 25);
console.log(nini.greet());  // Hello, Nini ğŸ‘‹
```

---

## ğŸ”¹ 6. Inheritance & `extends` ğŸ”¼

* Classes can **inherit** properties and methods from a parent class.
    

```typescript
class Employee extends Person {
    constructor(name: string, age: number, public jobTitle: string) {
        super(name, age); // call parent constructor
    }

    showJob() {
        return `${this.name} works as ${this.jobTitle}`;
    }
}

let niniEmp = new Employee("Nini", 25, "Developer");
console.log(niniEmp.greet());    // Hello, Nini ğŸ‘‹
console.log(niniEmp.showJob());  // Nini works as Developer
```

---

## ğŸ”¹ 7. Getters & Setters ğŸ’¡

* **Getter** â†’ access property
    
* **Setter** â†’ modify property with validation
    

```typescript
class Person {
    private _age: number;

    constructor(public name: string, age: number) {
        this._age = age;
    }

    get age() {
        return this._age;
    }

    set age(value: number) {
        if (value < 0) throw new Error("Age cannot be negative âŒ");
        this._age = value;
    }
}

let nini = new Person("Nini", 25);
console.log(nini.age); // 25
nini.age = 30;         // âœ… works
// nini.age = -5;      // âŒ Error
```

---

## ğŸ”¹ 8. Static Properties & Methods ğŸ·ï¸

* `static` â†’ belongs to the **class**, not instances
    

```typescript
class Person {
    static species: string = "Homo sapiens";

    static info() {
        return `Species: ${Person.species}`;
    }
}

console.log(Person.species);  // Homo sapiens
console.log(Person.info());   // Species: Homo sapiens
```

---

## ğŸ”¹ 9. Abstract Classes & Methods ğŸ›ï¸

* `abstract` â†’ class cannot be instantiated directly
    
* Must be **extended**
    
* Can contain **abstract methods** (must be implemented in derived class)
    

```typescript
abstract class Person {
    constructor(public name: string) {}
    abstract greet(): string;
}

class Employee extends Person {
    greet() {
        return `Hello, ${this.name} ğŸ‘‹`;
    }
}

let nini = new Employee("Nini");
console.log(nini.greet()); // Hello, Nini ğŸ‘‹
```

---

## ğŸ”¹ 10. Interfaces with Classes ğŸ§©

* Classes can **implement interfaces** to enforce structure
    

```typescript
interface IPerson {
    name: string;
    greet(): string;
}

class Person implements IPerson {
    constructor(public name: string) {}
    greet() {
        return `Hello, ${this.name} ğŸ‘‹`;
    }
}

let nini = new Person("Nini");
console.log(nini.greet()); // Hello, Nini ğŸ‘‹
```

---

## ğŸ”¹ 11. Summary Table ğŸ“Š

| Feature | Syntax / Example | Notes |
| --- | --- | --- |
| Basic Class | `class Person { ... }` | Properties + methods |
| Constructor | `constructor(...) { ... }` | Initializes object |
| Access Modifiers | `public/private/protected` | Control visibility |
| Readonly | `readonly name: string` | Assign once |
| Parameter Properties | `constructor(public name: string)` | Shortcut for property declaration |
| Inheritance | `class Employee extends Person` | `super()` calls parent constructor |
| Getters/Setters | `get age() {...} set age(...) {...}` | Controlled access |
| Static | `static species` | Belongs to class, not instance |
| Abstract Class | `abstract class` | Cannot instantiate, must extend |
| Interface | `implements IPerson` | Enforce class structure |

---

âœ… **Key Takeaways**

* TypeScript classes are **powerful for OOP** and similar to Java/C#.
    
* **Access modifiers, static, readonly, inheritance, abstract classes** make code safe and reusable.
    
* Use **interfaces + classes** together for **type safety and structure**.
    

# **10 TypeScript Interface**

## ğŸ”¹ 1. What is an Interface? ğŸ§©

* An **interface** defines the **shape of an object**: what properties and methods it should have.
    
* Itâ€™s a **TypeScript-only feature** (does not exist in JavaScript at runtime).
    
* Helps with **type safety, code readability, and consistency**.
    

---

## ğŸ”¹ 2. Basic Interface Syntax

```typescript
interface Person {
    name: string;
    age: number;
}

let nini: Person = {
    name: "Nini",
    age: 25
};

console.log(nini.name); // Nini
console.log(nini.age);  // 25
```

âœ… Notes:

* `Person` interface enforces that **objects must have** `name` and `age`.
    

---

## ğŸ”¹ 3. Optional Properties â“

* Some properties may not always exist.
    

```typescript
interface Person {
    name: string;
    age?: number;  // optional
}

let nini: Person = { name: "Nini" }; // âœ… allowed
```

---

## ğŸ”¹ 4. Readonly Properties ğŸ“

* Properties that **cannot be changed after assignment**.
    

```typescript
interface Person {
    readonly name: string;
    age: number;
}

let nini: Person = { name: "Nini", age: 25 };
// nini.name = "Alice"; // âŒ Error: readonly
```

---

## ğŸ”¹ 5. Methods in Interface

```typescript
interface Person {
    name: string;
    greet(): string;
}

let nini: Person = {
    name: "Nini",
    greet() {
        return `Hello, ${this.name} ğŸ‘‹`;
    }
};

console.log(nini.greet()); // Hello, Nini ğŸ‘‹
```

---

## ğŸ”¹ 6. Extending Interfaces ğŸ”¼

* Interfaces can **extend other interfaces** to reuse properties.
    

```typescript
interface Person {
    name: string;
    age: number;
}

interface Employee extends Person {
    jobTitle: string;
}

let nini: Employee = {
    name: "Nini",
    age: 25,
    jobTitle: "Developer"
};
```

---

## ğŸ”¹ 7. Implementing Interfaces in Classes ğŸ«

```typescript
interface Person {
    name: string;
    greet(): string;
}

class Developer implements Person {
    constructor(public name: string) {}
    greet(): string {
        return `Hello, ${this.name} ğŸ‘‹`;
    }
}

let niniDev = new Developer("Nini");
console.log(niniDev.greet()); // Hello, Nini ğŸ‘‹
```

---

## ğŸ”¹ 8. Indexable Types ğŸ”‘

* Define **dynamic property names**.
    

```typescript
interface StringArray {
    [index: number]: string;
}

let names: StringArray = ["Nini", "Alice", "Bob"];
console.log(names[0]); // Nini
```

---

## ğŸ”¹ 9. Function Types in Interfaces ğŸ§©

```typescript
interface Greet {
    (name: string): string;
}

let greet: Greet = (name) => `Hello, ${name} ğŸ‘‹`;
console.log(greet("Nini")); // Hello, Nini ğŸ‘‹
```

---

## ğŸ”¹ 10. Summary Table ğŸ“Š

| Feature | Syntax / Example | Notes |
| --- | --- | --- |
| Basic Interface | `interface Person { name: string; age: number }` | Enforces object shape |
| Optional Property | `age?: number` | Not required |
| Readonly Property | `readonly name: string` | Cannot modify |
| Method | `greet(): string` | Define functions in interface |
| Extend Interface | `interface Employee extends Person` | Inherit properties |
| Implement in Class | `class Dev implements Person` | Must include all properties & methods |
| Indexable Types | `[index: number]: string` | Dynamic property names |
| Function Types | `(name: string) => string` | Interface as function type |

---

âœ… **Key Takeaways**

* Interfaces are **blueprints for objects, functions, and classes**.
    
* Supports **optional, readonly, methods, function types, indexable types**.
    
* Can **extend other interfaces** and be **implemented by classes**.
    

# **Advanced Types**