---
title: "TypeScript"
datePublished: Tue Sep 30 2025 13:36:49 GMT+0000 (Coordinated Universal Time)
cuid: cmg6lpzu4000002js25bka678
slug: typescript
tags: codewithnini

---

## TypeScript

## ğŸ“˜ Introduction to TypeScript

---

## In below from this line (Lets study TypeScriptâ€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦) we start the basics.

## ğŸ”¹ 1. What is TypeScript?

* **TypeScript (TS)** is a **superset of JavaScript** created by Microsoft.
    
* Adds **static typing** and modern features to JavaScript.
    
* Code is written in `.ts` files and then **compiled (transpiled)** into plain JavaScript (`.js`) which runs in browsers or Node.js.
    

âœ… In short: **JavaScript + Type Safety + Modern Features = TypeScript**

![](https://www.typescripttutorial.net/wp-content/uploads/2020/05/what-is-typescript-compiler.png align="left")

---

## ğŸ”¹ 2. Why Use TypeScript ?

**The main goals of TypeScript are:**

* Catches errors **at compile time** instead of runtime.
    
* Helps with **autocompletion & IntelliSense** in editors.
    
* Makes **Page Object Models (POM)** more maintainable.
    
* Useful for **scalable frameworks** (many test cases, multiple testers).
    

Example:

```java
let age: number = "25"; // âŒ Error in TypeScript
let age: number = 25;   // âœ… Correct
```

---

## ğŸ”¹ 3. TypeScript vs JavaScript

| Feature | JavaScript (JS) | TypeScript (TS) |
| --- | --- | --- |
| Typing | Dynamic | Static + Dynamic |
| File extension | `.js` | `.ts` |
| Error checking | Runtime | Compile time |
| IDE support | Limited | Excellent (hints, IntelliSense) |
| Compilation required | âŒ No | âœ… Yes (to JS) |

---

## ğŸ”¹ 4. TypeScript Workflow

1. Install TypeScript:
    
    ```java
    npm install -g typescript
    ```
    
2. Compile `.ts` to `.js`:
    
    ```java
    tsc file.ts
    ```
    
3. Run JavaScript file with Node.js:
    
    ```java
    node file.js
    ```
    

---

## ğŸ”¹ 5. Key Features of TypeScript

### âœ… Strong Typing

```java
let user: string = "Nini";
let count: number = 10;
let isLoggedIn: boolean = true;
```

### âœ… Interfaces

Useful for describing object structure.

```java
interface User {
  username: string;
  password: string;
}
const admin: User = { username: "admin", password: "12345" };
```

### âœ… Classes & OOP

Supports **Object-Oriented Programming** (very useful in Playwright POM).

```java
class LoginPage {
  constructor(private page: Page) {}
  async login(user: string, pass: string) {
    await this.page.fill("#username", user);
    await this.page.fill("#password", pass);
    await this.page.click("#submit");
  }
}
```

### âœ… Async/Await

First-class support for handling Promises.

```java
async function run() {
  await page.goto("https://example.com");
}
```

### âœ… Modules

Organize code across files.

```java
// loginPage.ts
export class LoginPage { ... }

// test.ts
import { LoginPage } from './loginPage';
```

---

## ğŸ”¹ 6. TypeScript in Playwright

Playwright is written in TypeScript itself âœ…, so when you use TS:

* Better IntelliSense for locators & methods
    
* Autocomplete for [`page.click`](http://page.click), `page.goto`, etc.
    
* Easy error detection before running tests
    

Example:

```java
import { test, expect } from '@playwright/test';

test('basic test', async ({ page }) => {
  await page.goto('https://example.com');
  await expect(page).toHaveTitle(/Example/);
});
```

---

## ğŸ”¹ 7. Advantages of Using TypeScript in Automation

* âœ… **Scalability** â†’ Large frameworks are easier to manage.
    
* âœ… **Code readability** â†’ Clearer structure with types, interfaces.
    
* âœ… **IDE support** â†’ Faster coding with autocompletion.
    
* âœ… **Fewer bugs** â†’ Errors caught before running tests.
    
* âœ… **Reusability** â†’ Easy to build Page Objects and utilities.
    

---

âš¡ **Summary:**  
TypeScript is a **typed superset of JavaScript** that makes automation frameworks like Playwright **more reliable, maintainable, and developer-friendly**.

# **Before we learn we need to know the some of concepts**.

# why did Node.js come to the market in the first place? What problem did it solve?

## **The Background Before Node.js**

Before 2009 (when Node.js was introduced by Ryan Dahl), most web development looked like this:

* **JavaScript only ran in browsers** (for UI interactions).
    
* Server-side code was written in other languages like PHP, Java, Ruby, or .NET.
    
* Each client request was handled in a **blocking, multi-threaded** way â€” meaning each connection consumed a thread on the server.
    

This caused:

* **High memory consumption** with many connections.
    
* Poor scalability for real-time apps (e.g., chat, gaming, streaming).
    

---

## **Why Node.js Came to Market**

### **1\. To Use JavaScript on the Server**

* Until then, JavaScript was only client-side.
    
* Node.js brought **JavaScript to the backend**, enabling full-stack development with a single language.
    

---

### **2\. Non-blocking, Event-Driven Architecture**

* Traditional servers (like Apache with PHP) used **blocking I/O**: one thread waits for tasks (file read, database query) to complete.
    
* Node.js introduced **non-blocking I/O with an event loop**.
    
* This meant:
    
    * One thread can handle thousands of concurrent requests.
        
    * Great for **real-time apps (chat apps, streaming, APIs)**.
        

---

### **3\. High Performance with V8 Engine**

* Built on **Google Chrome's V8 engine**, Node.js executes JavaScript extremely fast.
    
* Compiles JS into machine code.
    

---

### **4\. Scalability and Lightweight**

* Uses **asynchronous callbacks, promises, async/await**.
    
* Runs on a **single-threaded event loop**, consuming fewer resources than multi-threaded servers.
    

---

### **5\. Huge Ecosystem (npm)**

* Node.js brought **npm (Node Package Manager)**, the worldâ€™s largest open-source library ecosystem.
    
* Made it easy to install, share, and update packages.
    

---

### **6\. Ideal for Modern Web Apps**

* Real-time chat (WhatsApp Web, Slack)
    
* Streaming services (Netflix, YouTube backend components)
    
* Microservices & APIs
    
* Automation tools (Playwright, Cypress)
    

---

## **In Simple Words**

Node.js came to the market to:

* **Break the wall between frontend and backend** (one language: JavaScript)
    
* **Handle high-concurrency applications efficiently**
    
* **Speed up development with a giant package ecosystem**
    
* **Enable real-time and scalable applications**
    

---

## **Analogy**

Old servers = Waiters who serve one table at a time (blocking).  
Node.js = A smart waiter who takes many orders, delivers them as theyâ€™re ready, and never waits idly.

## What is Node Package Manager (npm) is, how it came to exist, and Why it became essential for Node.js and the JavaScript ecosystem.

## **What is npm (Node Package Manager)?**

* **npm** is the default package manager for Node.js.
    
* It allows you to **install, share, manage, and update code packages (libraries, tools, frameworks)**.
    
* It comes bundled with Node.js (no need to install separately).
    

### **What Does npm Do?**

* Installs libraries like Express, React, Playwright, etc.
    
* Manages dependencies in your project via `package.json`.
    
* Allows you to publish your own packages.
    
* Provides access to the **worldâ€™s largest open-source library ecosystem**.
    

---

## **How Did npm Come? (The History)**

### **Before npm**

* JavaScript was mostly used in browsers.
    
* Developers relied on manually downloading libraries and linking them with `<script>` tags.
    
* Dependency management was a nightmare:
    
    * No central repository
        
    * Version conflicts (different libraries requiring different versions)
        
    * No standard way to share packages
        

### **The Birth of npm**

* **Created in 2010 by Isaac Z. Schlueter**, shortly after Node.js (2009).
    
* Built to solve:
    
    * **Package sharing** for Node.js
        
    * **Dependency management** in one place
        
    * **Version control** for libraries
        

### **npm's Growth**

* Quickly became the **standard package manager for Node.js**.
    
* Expanded to support frontend tools (React, Angular, Vue, TypeScript, Webpack).
    
* Now used not only in Node.js apps but also for automation, CI/CD, and even Python/.NET integrations.
    

---

## **How npm Works?**

1. You create a project:
    
    ```bash
    npm init -y
    ```
    
    â†’ Creates `package.json` (tracks dependencies and project metadata).
    
2. Install a package:
    
    ```bash
    npm install express
    ```
    
    â†’ Downloads package to `node_modules/` and updates `package.json`.
    
3. Use it in your code:
    
    ```javascript
    const express = require('express');
    ```
    
4. Update or remove packages easily:
    
    ```bash
    npm update
    npm uninstall express
    ```
    
5. Publish your own library:
    
    ```bash
    npm publish
    ```
    

---

## **Why npm is Important ?**

* Makes Node.js scalable and developer-friendly.
    
* Encourages code reuse (no need to rewrite common modules).
    
* Powers tools like Playwright, Selenium WebDriver JS, ESLint, TypeScript, etc.
    
* Became the **largest package ecosystem in the world (2M+ packages)**.
    

---

## **Alternatives to npm ?**

* **Yarn** (Facebookâ€™s alternative, faster installs, better caching).
    
* **pnpm** (space-efficient, symlink-based).
    
* **Bun** (modern, ultra-fast).
    

But npm remains the default and most widely supported.

## **1\. npm Workflow (Step by Step with Diagram)**

Hereâ€™s how npm works in a typical Node.js project:

```java
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Install Node.js     â”‚
 â”‚ (npm comes with it) â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Initialize Project  â”‚
 â”‚ npm init -y         â”‚
 â”‚ â†’ creates package.jsonâ”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Install Packages    â”‚
 â”‚ npm install <pkg>   â”‚
 â”‚ â†’ node_modules/     â”‚
 â”‚ â†’ package-lock.json â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Use in Code         â”‚
 â”‚ require()/import    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Update/Remove       â”‚
 â”‚ npm update / uninstallâ”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Share Your Project  â”‚
 â”‚ via package.json    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Publish Your Packageâ”‚
 â”‚ npm publish         â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## **2\. Key npm Commands (Automation & Testing Focus)**

### **Project Setup**

* `npm init -y` â†’ Creates a default `package.json`
    
* `npm install` â†’ Installs all dependencies listed in `package.json`
    

### **Installing Tools**

* Playwright:
    
    ```bash
    npm install -D @playwright/test
    npx playwright install
    ```
    
* Selenium WebDriver:
    
    ```bash
    npm install selenium-webdriver
    ```
    
* TypeScript:
    
    ```bash
    npm install -D typescript ts-node @types/node
    ```
    

### **Running Tests**

* Using Playwright:
    
    ```bash
    npx playwright test
    ```
    
* Using Selenium with Node:
    
    ```bash
    node your_test.js
    ```
    

### **Updating Dependencies**

* Update all:
    
    ```bash
    npm update
    ```
    
* Update a specific package:
    
    ```bash
    npm install <package>@latest
    ```
    

### **Other Important Commands**

* `npm list` â†’ View installed packages
    
* `npm outdated` â†’ Check for outdated packages
    
* `npm uninstall <package>` â†’ Remove a package
    
* `npm cache clean --force` â†’ Clear npm cache
    

---

## **3\. npm vs Maven (For Automation Testing)**

Youâ€™re already learning **Maven** for Java automation, so hereâ€™s a direct comparison:

| **Feature** | **npm (Node.js**) | **Maven (Java)** |
| --- | --- | --- |
| **Language Focus** | JavaScript/TypeScript | Java, Kotlin |
| **Dependency File** | `package.json` | `pom.xml` |
| **Package Repository** | npm registry (2M+ packages) | Maven Central (1M+ packages) |
| **Execution** | `npm run`, `npx` | `mvn clean install`, `mvn test` |
| **Build System** | No default build (Webpack, Rollup, etc.) | Built-in build lifecycle |
| **Test Integration** | Playwright, Jest, Mocha, Cypress | TestNG, JUnit, Selenium |
| **Usage in QA** | Web/API automation (Playwright, Cypress) | Web/API automation (Selenium, REST-Assured) |
| **Installation** | `npm install` (fast, lightweight) | `mvn install` (slower, XML heavy) |

### **When to Use npm in Automation?**

* Playwright, Cypress, Puppeteer automation
    
* API testing with Supertest or Axios
    
* TypeScript-based frameworks
    

### **When to Use Maven in Automation?**

* Selenium + Java/TestNG/JUnit projects
    
* RestAssured, Cucumber with Java
    
* Enterprise CI/CD pipelines using Java stack.
    
    # **Before leaening TypeScript or Playwright just UnderStand the below Topics.**
    

# ğŸ“˜ JavaScript Modules

---

## 1ï¸âƒ£ What Are Modules?

* A **module** is a file in JavaScript that **exports** variables, functions, or classes so they can be **imported** in another file.
    
* Modules help **organize code**, **avoid polluting global scope**, and **increase maintainability**.
    

**Example:**

```bash
// mathUtils.js
export function add(a, b) {
  return a + b;
}
export const PI = 3.14;

// main.js
import { add, PI } from './mathUtils.js';
console.log(add(5, 3)); // 8
console.log(PI);        // 3.14
```

âœ… Key points:

* Use `export` to make variables/functions/classes available outside the module.
    
* Use `import` to access exported content in another module.
    

---

## 2ï¸âƒ£ Types of Exports

### Named Export

```bash
// utils.js
export function greet(name) { return `Hello ${name}`; }
export const version = "1.0";

// app.js
import { greet, version } from './utils.js';
console.log(greet("Nini")); // Hello Nini
```

### Default Export

* A module can have **one default export**, which can be imported with any name.
    

```bash
// logger.js
export default function log(message) { console.log(message); }

// app.js
import logFunc from './logger.js';
logFunc("Test started"); // Test started
```

---

## 3ï¸âƒ£ Dynamic Import

* **Dynamic import** allows importing a module **at runtime**, not at the start.
    
* Returns a **Promise**, useful for **lazy loading modules**.
    

```bash
async function run() {
  const math = await import('./mathUtils.js');
  console.log(math.add(2, 3)); // 5
}
run();
```

âœ… Use cases:

* Load modules **only when needed** (performance optimization).
    
* Conditional module loading:
    

```bash
if (condition) {
  const module = await import('./featureA.js');
  module.runFeature();
}
```

---

## 4ï¸âƒ£ Top-Level Await in Modules

* **Top-level await** allows using `await` **outside of async functions** at the top of a module.
    
* Only works **inside ES modules** (files with `.js` using `type: "module"` or `.mjs` files).
    

```bash
// dataLoader.js
const response = await fetch('https://api.example.com/data');
const data = await response.json();
console.log(data);
```

âœ… Advantages:

* Makes async initialization simpler.
    
* Useful for loading configuration, test data, or setup before running automation tests.
    

---

## 5ï¸âƒ£ Using Modules in Node.js / Playwright

* In **Node.js / Playwright**, enable ES modules by:
    
    * Using `"type": "module"` in `package.json`
        
    * Or naming files `.mjs`
        

```bash
// package.json
{
  "name": "playwright-project",
  "type": "module"
}
```

* Example in Playwright:
    

```bash
// pageObjects/loginPage.js
export class LoginPage {
  constructor(page) { this.page = page; }
  async login(user, pass) {
    await this.page.fill('#username', user);
    await this.page.fill('#password', pass);
    await this.page.click('button[type=submit]');
  }
}

// tests/login.test.js
import { test } from '@playwright/test';
import { LoginPage } from '../pageObjects/loginPage.js';

test('login test', async ({ page }) => {
  const login = new LoginPage(page);
  await login.login('admin', '12345');
});
```

---

âœ… **Summary:**

* **Modules**: OrgağŸ“˜ JavaScript Modules
    
    ---
    
    ## 1ï¸âƒ£ What Are Modules?
    
    * A **module** is a file in JavaScript that **exports** variables, functions, or classes so they can be **imported** in another file.
        
    * Modules help **organize code**, **avoid polluting global scope**, and **increase maintainability**.
        
    
    **Example:**
    
    ```bash
    // mathUtils.js
    export function add(a, b) {
      return a + b;
    }
    export const PI = 3.14;
    
    // main.js
    import { add, PI } from './mathUtils.js';
    console.log(add(5, 3)); // 8
    console.log(PI);        // 3.14
    ```
    
    âœ… Key points:
    
    * Use `export` to make variables/functions/classes available outside the module.
        
    * Use `import` to access exported content in another module.
        
    
    ---
    
    ## 2ï¸âƒ£ Types of Exports
    
    ### Named Export
    
    ```bash
    // utils.js
    export function greet(name) { return `Hello ${name}`; }
    export const version = "1.0";
    
    // app.js
    import { greet, version } from './utils.js';
    console.log(greet("Nini")); // Hello Nini
    ```
    
    ### Default Export
    
    * A module can have **one default export**, which can be imported with any name.
        
    
    ```bash
    // logger.js
    export default function log(message) { console.log(message); }
    
    // app.js
    import logFunc from './logger.js';
    logFunc("Test started"); // Test started
    ```
    
    ---
    
    ## 3ï¸âƒ£ Dynamic Import
    
    * **Dynamic import** allows importing a module **at runtime**, not at the start.
        
    * Returns a **Promise**, useful for **lazy loading modules**.
        
    
    ```bash
    async function run() {
      const math = await import('./mathUtils.js');
      console.log(math.add(2, 3)); // 5
    }
    run();
    ```
    
    âœ… Use cases:
    
    * Load modules **only when needed** (performance optimization).
        
    * Conditional module loading:
        
    
    ```bash
    if (condition) {
      const module = await import('./featureA.js');
      module.runFeature();
    }
    ```
    
    ---
    
    ## 4ï¸âƒ£ Top-Level Await in Modules
    
    * **Top-level await** allows using `await` **outside of async functions** at the top of a module.
        
    * Only works **inside ES modules** (files with `.js` using `type: "module"` or `.mjs` files).
        
    
    ```bash
    // dataLoader.js
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
    ```
    
    âœ… Advantages:
    
    * Makes async initialization simpler.
        
    * Useful for loading configuration, test data, or setup before running automation tests.
        
    
    ---
    
    ## 5ï¸âƒ£ Using Modules in Node.js / Playwright
    
    * In **Node.js / Playwright**, enable ES modules by:
        
        * Using `"type": "module"` in `package.json`
            
        * Or naming files `.mjs`
            
    
    ```bash
    // package.json
    {
      "name": "playwright-project",
      "type": "module"
    }
    ```
    
    * Example in Playwright:
        
    
    ```bash
    // pageObjects/loginPage.js
    export class LoginPage {
      constructor(page) { this.page = page; }
      async login(user, pass) {
        await this.page.fill('#username', user);
        await this.page.fill('#password', pass);
        await this.page.click('button[type=submit]');
      }
    }
    
    // tests/login.test.js
    import { test } from '@playwright/test';
    import { LoginPage } from '../pageObjects/loginPage.js';
    
    test('login test', async ({ page }) => {
      const login = new LoginPage(page);
      await login.login('admin', '12345');
    });
    ```
    
    ---
    
    âœ… **Summary:**
    
    * **Modules**: Organize and export code.
        
    * **Dynamic Import**: Load modules at runtime.
        
    * **Top-level Await**: Use `await` outside async functions at the module top level.
        
    * **Playwright Use**: Modularize POMs, utilities, and test scripts using ES modules.nize and export code.
        
* **Dynamic Import**: Load modules at runtime.
    
* **Top-level Await**: Use `await` outside async functions at the module top level.
    
* **Playwright Use**: Modularize POMs, utilities, and test scripts using ES modules.
    

âœ… Letâ€™s compare **JavaScript/TypeScript modules, dynamic import, and top-level await** with **Java equivalents** so itâ€™s easy to relate.

---

## ğŸ“Š Comparison: JS Modules vs Java

| Feature | JavaScript / TypeScript | Java Equivalent | Example |
| --- | --- | --- | --- |
| **Modules / Imports** | `export` / `import` | `public class` + `import package.Class` | JS: |
| `js export class Login {} import { Login } from './Login.js';` |  |  |  |
| Java: |  |  |  |
| `java package pages; public class Login {} import pages.Login;` |  |  |  |
| **Named Export / Import** | Multiple exports per file | Multiple public classes or methods in packages | JS: |
| `export function add(){} export const PI=3.14;` |  |  |  |
| Java: |  |  |  |
| `public class MathUtils { public static final double PI=3.14; public static int add(int a,int b){return a+b;} }` |  |  |  |
| **Default Export** | One default export per module | Class itself as main exposed API | JS: |
| `export default class Logger{} import Logger from './Logger.js';` |  |  |  |
| Java: |  |  |  |
| `public class Logger {} // import pages.Logger;` |  |  |  |
| **Dynamic Import** | `import()` at runtime, returns Promise | Reflection or Class.forName() | JS: |
| `const module = await import('./math.js');` |  |  |  |
| Java: |  |  |  |
| `Class<?> clazz = Class.forName("pages.Login"); Object obj = clazz.getDeclaredConstructor().newInstance();` |  |  |  |
| **Top-level Await** | Can use `await` outside async function in module | Java doesnâ€™t allow await at top level; must use `main` or another async context | JS: |
| `const data = await fetch(url);` |  |  |  |
| Java: |  |  |  |
| `CompletableFuture<String> data = httpClient.sendAsync(request, BodyHandlers.ofString()); data.thenAccept(System.out::println);` |  |  |  |

---

### ğŸ”¹ Key Observations:

1. **Modules:** Both organize code; JS uses file-based exports, Java uses packages & public classes.
    
2. **Dynamic import:** JS supports runtime loading natively; Java requires reflection (`Class.forName`).
    
3. **Top-level await:** JS modules allow simpler async initialization; Java always needs an **async context** (like `CompletableFuture` or threads).
    

---

### âš¡ Example: Playwright-like Page Object

**JavaScript / TypeScript (Module + POM + Await):**

```javascript
// loginPage.js
export class LoginPage {
  constructor(page) { this.page = page; }
  async login(user, pass) {
    await this.page.fill('#username', user);
    await this.page.fill('#password', pass);
    await this.page.click('#submit');
  }
}

// test.js
import { LoginPage } from './loginPage.js';
const login = new LoginPage(page);
await login.login('admin', '12345');
```

**Java (Selenium Page Object):**

```java
// LoginPage.java
package pages;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.By;

public class LoginPage {
    WebDriver driver;
    public LoginPage(WebDriver driver) { this.driver = driver; }
    public void login(String user, String pass) {
        driver.findElement(By.id("username")).sendKeys(user);
        driver.findElement(By.id("password")).sendKeys(pass);
        driver.findElement(By.id("submit")).click();
    }
}

// LoginTest.java
import pages.LoginPage;
LoginPage login = new LoginPage(driver);
login.login("admin","12345");
```

âœ… As you can see:

* **Module import/export** in JS â‰ˆ **package + import** in Java.
    
* **Async / Await** in JS â‰ˆ **WebDriver waits / threads / CompletableFuture** in Java.
    
* Dynamic import in JS â‰ˆ Reflection in Java.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759252853515/0fdc346d-9cfa-41f0-ae49-f10936a0ee04.png align="center")

## Statically and Dynamically Type Language

## **Typing Concepts**

| Feature | Statically Typed Language | Dynamically Typed Language |
| --- | --- | --- |
| **Definition** | Variable types are known at **compile time**. | Variable types are determined at **runtime**. |
| **Type Checking** | Done during compilation. | Done during execution. |
| **Error Detection** | Many type-related errors are caught **before running the code**. | Type errors appear only when the code executes. |
| **Flexibility** | Less flexible, more strict. | More flexible, allows implicit type changes. |
| **Examples** | Java, TypeScript | JavaScript, Python |

---

## **2\. Comparison Using JS, TS, and Java**

### **JavaScript (Dynamically Typed)**

```javascript
let x = 10;    // x is number now
x = "Hello";   // x is now string, no error
console.log(x); // Output: Hello
```

* JS doesnâ€™t enforce types.
    
* A variable can change its type at any time.
    
* Errors like adding a string to a number are only found at runtime.
    

---

### **TypeScript (Statically Typed)**

```javascript
let x: number = 10;
x = "Hello"; // âŒ Error: Type 'string' is not assignable to type 'number'
```

* TS is statically typed (optional, but recommended).
    
* Types are checked at **compile time**.
    
* Helps catch errors early before running the code.
    
* You can also use `any` type for dynamic behavior:
    

```javascript
let y: any = 10;
y = "Hello"; // âœ… No error
```

---

### **Java (Statically Typed)**

```javascript
int x = 10;
x = "Hello"; // âŒ Compile-time error
```

* Java is strictly statically typed.
    
* You must declare the type of every variable.
    
* Errors are caught during compilation.
    

---

## **3\. Key Differences Between JS, TS, and Java**

| Feature | JavaScript | TypeScript | Java |
| --- | --- | --- | --- |
| Typing | Dynamic | Static (optional) | Static |
| Compilation | Interpreted | Compiled to JS | Compiled to bytecode |
| Type Safety | Low | High | Very High |
| Variable Reassignment | Any type | Must follow declared type | Must follow declared type |
| Error Detection | Runtime | Compile-time | Compile-time |
| Popular Use | Web | Web, Large-scale apps | Enterprise, Backend, Android |

---

### **Summary**

* **JS:** Flexible but prone to runtime errors.
    
* **TS:** Adds static typing to JS â†’ safer, easier to maintain.
    
* **Java:** Fully statically typed â†’ very strict, robust for large apps.
    

---

If you want, I can also make a **diagram showing JS vs TS vs Java type checking** in a simple visual way thatâ€™s easy to remember.

Do you want me to do that?

##### You said:

ok

###### ChatGPT said:

Perfect! Here's a simple visual diagram comparing **JavaScript, TypeScript, and Java** in terms of typing and error detection:

---

### **Type System Comparison Diagram**

```javascript
             +-------------------------+
             |      JavaScript         |
             |  Dynamically Typed      |
             |  Type checked at runtime|
             |  Flexible, but risky   |
             +-------------------------+
                        |
                        v
             +-------------------------+
             |      TypeScript         |
             |  Statically Typed       |
             |  Type checked at compile|
             |  Can catch errors early |
             |  Safer than JS          |
             +-------------------------+
                        |
                        v
             +-------------------------+
             |         Java            |
             |  Statically Typed       |
             |  Strict compile-time    |
             |  Very robust & safe     |
             +-------------------------+
```

---

### **Quick Example Table**

| Language | Variable Declaration | Type Checking | Example Error |
| --- | --- | --- | --- |
| JavaScript | `let x = 10;` | Runtime | `x = "Hello"; // ok at compile, fails at runtime if logic depends on number` |
| TypeScript | `let x: number = 10;` | Compile-time | `x = "Hello"; // âŒ Error at compile time` |
| Java | `int x = 10;` | Compile-time | `x = "Hello"; // âŒ Error at compile time` |

---

âœ… **Takeaway:**

* JS = flexible, runtime errors
    
* TS = JS + static type safety
    
* Java = strict static typing
    

# Lets study TypeScriptâ€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦

## Coomads need to know..

## **ğŸ“˜ Node.js Commands**

| Command | Description |
| --- | --- |
| `node -v` | Check Node.js version |
| `npm -v` | Check npm version |
| `npm init` | Initialize a new project (interactive) |
| `npm init -y` | Initialize a new project with default settings |
| `npm install <package>` | Install package locally |
| `npm install -g <package>` | Install package globally |
| `npm install --save <package>` | Add package to dependencies |
| `npm install --save-dev <package>` | Add package to devDependencies |
| `npm uninstall <package>` | Remove a package |
| `npm update <package>` | Update a package |
| `node app.js` | Run a JS file |
| `nodemon app.js` | Run with auto-reload (requires nodemon) |
| `npm start` | Run start script from package.json |
| `npm run <script>` | Run custom script from package.json |
| `npm list -g --depth=0` | List global packages |
| `npm outdated` | Check outdated packages |
| `node` | Start Node.js REPL (interactive console) |
| `node --inspect app.js` | Debug Node.js file using Chrome DevTools |
| `node --trace-warnings app.js` | Show runtime warnings |

---

## **ğŸ“˜ TypeScript Commands**

| Command | Description |
| --- | --- |
| `npm install -g typescript` | Install TypeScript globally |
| `tsc -v` | Check TypeScript version |
| `tsc --init` | Initialize a TypeScript project (`tsconfig.json`) |
| `tsc app.ts` | Compile a single TypeScript file to JavaScript |
| `tsc` | Compile project using `tsconfig.json` |
| `tsc -w` | Watch mode â€“ automatically compile on file changes |
| `tsc app.ts --target ES6` | Compile TS file targeting ES6 JS |
| `tsc app.ts --outDir ./dist` | Set output directory for compiled JS |
| `tsc app.ts --module commonjs` | Set module system |
| `ts-node app.ts` | Run TypeScript file directly without compiling (requires `ts-node`) |
| `tsc --listFiles` | List all files compiled by TypeScript |
| `tsc --diagnostics` | Show compilation statistics |
| `tsc --init --strict` | Create `tsconfig.json` with strict mode enabled |
| `tslint -c tslint.json 'src/**/*.ts'` | Lint TypeScript files (requires `tslint`) |
| `prettier --write "src/**/*.ts"` | Format TypeScript files (requires `prettier`) |

---

âœ… **Tip:**

* **Node.js commands** are mostly for runtime, package management, and debugging.
    
* **TypeScript commands** focus on compilation, type checking, and project configuration.
    

## **1\. Introduction to TypeScript**

* TypeScript is a **superset of JavaScript** that adds **static types**.
    
* Compiles to plain JavaScript: `tsc filename.ts`
    
* Advantages:
    
    * Early error detection
        
    * Better IDE support (autocomplete, intellisense)
        
    * Large-scale app maintainability
        

---

## **2\. Installing TypeScript**

```javascript
# Install globally
npm install -g typescript

# Check version
tsc -v

# Compile TypeScript to JavaScript
tsc app.ts
```

* Run JS file: `node app.js`
    

---

## **3\. Basic Types**

| Type | Example |
| --- | --- |
| `boolean` | `let isDone: boolean = true;` |
| `number` | `let count: number = 10;` |
| `string` | `let name: string = "Nini";` |
| `array` | `let arr: number[] = [1,2,3];` |
| `tuple` | `let tuple: [string, number] = ["hello", 10];` |
| `enum` | `enum Color {Red, Green, Blue}; let c: Color =` [`Color.Green`](http://Color.Green)`;` |
| `any` | `let value: any = 5; value = "hello";` |
| `void` | `function log(): void { console.log("hi"); }` |
| `null/undefined` | `let u: undefined = undefined; let n: null = null;` |
| `never` | `function error(): never { throw new Error("error"); }` |

---

## **4\. Variables and Constants**

```javascript
let x: number = 10;  // mutable
const y: string = "Hello"; // immutable
```

* `let` â†’ block-scoped variable
    
* `const` â†’ block-scoped constant
    
* `var` â†’ function-scoped (avoid in modern TS/JS)
    

---

## **5\. Functions**

```javascript
// Named function with typed params and return
function add(a: number, b: number): number {
    return a + b;
}

// Optional parameter
function greet(name?: string): string {
    return `Hello ${name || "Guest"}`;
}

// Default parameter
function multiply(a: number, b: number = 2): number {
    return a * b;
}

// Rest parameter
function sum(...numbers: number[]): number {
    return numbers.reduce((a, b) => a + b, 0);
}
```

---

## **6\. Interfaces**

* Define **object shapes** and enforce structure.
    

```javascript
interface Person {
    name: string;
    age: number;
    greet(): void;
}

let user: Person = {
    name: "Nini",
    age: 25,
    greet() { console.log("Hello!"); }
};
```

* Optional properties: `age?: number`
    
* Readonly properties: `readonly id: number`
    

---

## **7\. Classes & OOP**

```javascript
class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    move(distance: number = 0) {
        console.log(`${this.name} moved ${distance}m`);
    }
}

class Dog extends Animal {
    bark() { console.log("Woof!"); }
}

let dog = new Dog("Buddy");
dog.bark();
dog.move(10);
```

* **Access Modifiers**: `public` (default), `private`, `protected`
    
* **Readonly properties**: cannot be modified outside constructor
    
* **Static properties/methods**: belong to class, not instance
    

---

## **8\. Generics**

```javascript
function identity<T>(arg: T): T {
    return arg;
}

let output = identity<string>("Hello");
let num = identity<number>(42);

// Generic interface
interface GenericIdentity<T> {
    (arg: T): T;
}
```

* Generics allow **type-safe reusable components**.
    

---

## **9\. Type Aliases & Union Types**

```javascript
type ID = string | number;

let userId: ID;
userId = 123;
userId = "abc";

type Point = { x: number; y: number };
let p: Point = { x: 10, y: 20 };
```

* **Union types:** `string | number` â†’ variable can hold multiple types
    
* **Intersection types:** `type AB = A & B` â†’ merge types
    

---

## **10\. Type Assertions & Casting**

```javascript
let someValue: any = "Hello TS";
let strLength: number = (someValue as string).length;

// alternative syntax
let strLength2: number = (<string>someValue).length;
```

* Tells compiler: â€œtrust me, this variable is of this typeâ€
    

---

## **11\. Modules & Namespaces**

```javascript
// export.ts
export const PI = 3.14;
export function calculateArea(radius: number) { return PI * radius * radius; }

// import.ts
import { PI, calculateArea } from "./export";
console.log(calculateArea(5));
```

* **ES Modules** supported: `export` / `import`
    
* Use `namespace` for grouping in global scope (less common)
    

---

## **12\. Advanced Types**

| Feature | Example |
| --- | --- |
| Literal Types | \`let direction: "left" |
| Type Guards | `if (typeof value === "string") { ... }` |
| keyof | `type Keys = keyof Person;` |
| Conditional Types | `type Message<T> = T extends string ? string : number;` |
| Mapped Types | `type Readonly<T> = { readonly [K in keyof T]: T[K] };` |

---

## **13\. Decorators (Experimental)**

* Decorators add metadata or modify class behavior
    

```javascript
function Log(target: any, propertyKey: string) {
    console.log(`${propertyKey} decorated`);
}

class MyClass {
    @Log
    myMethod() { console.log("Hello"); }
}
```

* Enable in `tsconfig.json`:
    

```javascript
"experimentalDecorators": true
```

---

## **14\. Utility Types (Built-in)**

| Utility | Description |
| --- | --- |
| `Partial<T>` | Makes all properties optional |
| `Required<T>` | Makes all properties required |
| `Readonly<T>` | Makes all properties readonly |
| `Pick<T, K>` | Picks specific properties from type |
| `Omit<T, K>` | Omits specific properties from type |

---

## **15\. TypeScript Compiler Options**

Key options in `tsconfig.json`:

```javascript
{
  "target": "ES6",
  "module": "commonjs",
  "strict": true,
  "esModuleInterop": true,
  "outDir": "./dist",
  "rootDir": "./src",
  "sourceMap": true
}
```

* `"strict": true` â†’ enables strict type-checking
    
* `"esModuleInterop": true` â†’ allows default import of CommonJS modules
    

---

## **16\. TypeScript with Node & Browser**

* Node: `tsc` â†’ compile â†’ `node dist/app.js`
    
* Browser: use bundlers (Webpack, Vite) to compile TS â†’ JS
    

---

## âœ… **Summary**

TypeScript is **typed JavaScript** that improves maintainability, reduces runtime errors, and supports modern JS features plus static type safety. Key pillars:

1. Types (`string`, `number`, `boolean`, `any`, `tuple`, `enum`)
    
2. Interfaces & Classes (OOP)
    
3. Generics (reusable components)
    
4. Modules & Namespaces
    
5. Advanced Types (`union`, `intersection`, `conditional`)
    
6. Compiler & Config (`tsconfig.json`)
    

# **01 What is TypeScript**

# **02 TypeScript Setup**

The following tools you need to set up to start with TypeScript:

* **Visual Studio Code or VS Code** â€“ a code editor supporting TypeScript.
    
* **Node.js** â€“ Node.js is the environment in which you will run the TypeScript compiler.
    
* **TypeScript compiler** â€“ a Node.js module that compiles TypeScript into JavaScript.
    

If you use VS Code, you can install the following extension to speed up the development process:

* [Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) â€“ allows you to launch a development local web server with the hot reload feature.
    

## **Install Node.js**

**Install** node.js and open Command Prompt on Windows and type the command `node -v`, it should show the installed version of Node.js.

## **Install TypeScript compiler**

To install the TypeScript compiler, you launch the Terminal on macOS or Linux and Command Prompt on Windows and type the following command:

```bash
// global
npmÂ installÂ -gÂ typescript 
// or
// local (This keeps your project self-contained and avoids version mismatches.
npm install --save-dev typescript 
```

After the installation, you can type the following command to check the current version of the TypeScript **tsc --v**

It should return the version like this: **Version 5.8.3**

## **Install tsx module**

If you want to run TypeScript code directly on Node.js without precompiling, you can use the `tsx` module.

## **Summary**

* A TypeScript compiler compiles the TypeScript into JavaScript.
    
* Use the `tsc` command to compile a TypeScript file to a JavaScript file.
    
* Use the `tsx` module to run TypeScript directly on Node.js without precompiling it to JavaScript.
    

# **03 TypeScript â€œHello, Nini!â€**

## **TypeScript Hello Nini program in Node.js**

* launch VS Code create a directory as **TypeScript** and inside create another child directoty as **TypeScript\_Tutorial** . and install all as **local (**This keeps the project self-contained and avoids version mismatches).
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759317474112/99f83038-486c-4f8c-9c18-b2b2197ebb84.png align="center")
    
    Inside **TypeScript\_Tutorial** project create a new directory as **HelloNini** and Inside **HelloNini-derectory** create a new TypeScript file called `app.ts`. The extension of a TypeScript file is `.ts`.
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759317867674/677c3615-b682-474b-ade5-d9ff11b5661f.png align="center")
    
    Here i have added another file as **README.md** file to give extra information about the project.
    
* And type the following source code in the `app.ts` file.
    
    ```typescript
    let message: string = 'Hello, Nini!';
    console.log(message);
    ```
    
    Right-Click on directoty and **open in integrated Terminal** to compile the **.ts** file .
    
* type the following command on the Terminal to compile the `tsc app.ts` and click **enter.**
    
* If everything is fine, youâ€™ll see a new file called `app.js` is generated by the TypeScript compiler.
    
* ![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759318745101/20e10e14-3032-4d05-9141-3ffa25aafde1.png align="center")
    
    To run the `app.js` file in `Node.js`, type following command in same directory `node app.js` and Click on Enter.
    
* If everything is fine, it will show the output in console.
    
    **OUTPUT:**
    
    ```bash
    hp@NINI MINGW64 /TypeScript/TypeScript_Tutorial/HelloNini (main)
    $ node app.js
    Hello, Nini!
    ```
    

If you installed the `tsx` module you can use just one command to run the TypeScript file directly on Node.js without precompiling it to JavaScript:

```bash
tsx app.ts
```

# **04 Why TypeScript ?**

## **Why use TypeScript**

There are two main reasons to use TypeScript:

* TypeScript adds a type system to help you avoid many problems with dynamic types in JavaScript.
    
* TypeScript implements the future ***features*** of JavaScript **ES Next** so you can use them today.
    

**This tutorial focuses on the first reason.**

## **Understanding dynamic type in JavaScript**

JavaScript is dynamically typed. Unlike statically typed languages such as Java or C#, **values have types instead of variables**.

**JavaScript is dynamically typed**. Let me explain with a clear example.

---

## ğŸ”¹ In JavaScript (Dynamically Typed)

* **Variables donâ€™t have fixed types**.
    
* The **value** determines the type, not the variable.
    
* You can reassign different types to the same variable.
    

âœ… Example:

```javascript
let value = 42;          // number
console.log(typeof value); // "number"

value = "hello";         // âœ… allowed, now it's a string
console.log(typeof value); // "string"

value = true;            // âœ… allowed, now it's a boolean
console.log(typeof value); // "boolean"
```

ğŸ‘‰ Here, **value** of **variable** keeps changing **type** depending on the value.

ğŸ‘‰ **Variables** donâ€™t have a fixed **type**, only the **value** has a type.

---

## ğŸ”¹ In Java / C# (Statically Typed)

* **Variables have fixed types**.
    
* Once declared, you cannot assign a different type.
    

âœ… Java Example:

```java
public class Main {
    public static void main(String[] args) {
        int value = 42;      // int type fixed
        System.out.println(value);

        // value = "hello";  // âŒ ERROR: incompatible types
        // value = true;     // âŒ ERROR: cannot convert boolean to int
    }
}
```

ğŸ‘‰Variables **must have a type** and it **cannot change**.

---

## ğŸ“Š Key Difference

| **Feature** | **JavaScript** (Dynamic) | **Java**/**C#** (Static) |
| --- | --- | --- |
| Type Binding | At runtime | At compile-time |
| Variable has type? | âŒ No, value has type | âœ… Yes, variable fixed type |
| Flexibility | High (can reassign) | Low (strict typing) |
| Error detection | At runtime | At compile-time |

---

## ğŸ”¹ TypeScript (Static Typing on top of JavaScript)

```typescript
let value: number = 42;  
console.log(value);

value = "hello";   // âŒ ERROR: Type 'string' is not assignable to type 'number'
value = true;      // âŒ ERROR: Type 'boolean' is not assignable to type 'number'
```

ğŸ‘‰ TypeScript works like Java in terms of typing but **still compiles to JavaScript**.

âœ… This is why TypeScript was created â†’ to add **static typing** to JavaScript for better safety. we called it **typeSafety**.

## ğŸ“Š Quick Comparison

| Feature | JavaScript | Java | TypeScript |
| --- | --- | --- | --- |
| Typing | Dynamic (runtime) | Static (compile-time) | Static (compile-time, but compiles to JS) |
| Variable type fixed? | âŒ No | âœ… Yes | âœ… Yes |
| Flexibility | High | Low | Medium (strict, but allows `any`) |
| Example behavior | Same variable can be number â†’ string â†’ boolean | Not allowed | Not allowed |

---

âš¡ **Summary:**

* JavaScript â†’ variables can hold any type, changes at runtime.
    
* Java â†’ variable type fixed at compile time.
    
* TypeScript â†’ adds Java-like strict typing to JavaScript.
    

# **04 TypeScript Types**

## ğŸ”¹ What is a Type in TypeScript?

A **type** in TypeScript is a way to describe the **shape** or **kind of data** a variable, parameter, or function can hold.

* It tells the compiler **what kind of values** are allowed.
    
* Example:
    
    ```javascript
    let age: number = 25;   // type: number
    let name: string = "Nini"; // type: string
    let isAdmin: boolean = true; // type: boolean
    ```
    

ğŸ‘‰ In short: A **type is like a contract** that ensures variables and functions are used correctly.

---

## ğŸ”¹ Types in TypeScript

Types are broadly categorized into **two groups**:

### 1\. **Primitive Types**

Basic building blocks (same as in Java/JavaScript but with strict typing).

* `number` â†’ integers, floats, etc.
    
* `string` â†’ text values
    
* `boolean` â†’ true/false
    
* `null`
    
* `undefined`
    
* `bigint` â†’ very large numbers
    
* `symbol` â†’ unique identifiers
    

âœ… Example:

```javascript
let count: number = 10;
let username: string = "Nini";
let loggedIn: boolean = false;
```

---

### 2\. **Special & Advanced Types**

* `any` â†’ can hold **anything** (least safe).
    
* `unknown` â†’ safer alternative to `any` (must check before using).
    
* `void` â†’ function doesnâ€™t return anything.
    
* `never` â†’ function never returns (e.g., throws error).
    
* `object` â†’ non-primitive values.
    
* `array` â†’ list of elements (`number[]`, `string[]`).
    
* `tuple` â†’ fixed-size array with known types.
    
* `enum` â†’ named constants.
    
* **Custom types** â†’ `type` and `interface`.
    

âœ… Example:

```javascript
let data: any = 42; // can be number, string, etc.
let values: number[] = [1, 2, 3];
let tupleEx: [string, number] = ["Age", 25];

enum Role { Admin, User, Guest }
let role: Role = Role.Admin;
```

---

## ğŸ”¹ **Purposes of types in TypeScript**

There are two main purposes of types in TypeScript:

* First, types are used by the TypeScript compiler to analyze your code for **errors**.
    
* Second, types allow you to understand what values are associated with variables.
    

1. **Error Prevention (Safety)**
    
    * Catches mistakes at compile time (before running).
        
    
    ```javascript
    let age: number = 25;
    age = "twenty-five"; // âŒ ERROR
    ```
    
2. **Readability & Documentation**
    
    * Makes code easier to understand.
        
    
    ```javascript
    function greet(name: string): string {
      return "Hello, " + name;
    }
    ```
    
    **Other Purpose are :**
    
    **IntelliSense & Autocomplete**
    
    * Editors (like VS Code) can suggest methods and properties.
        
    
    **Scalability**
    
    * Large teams/projects benefit from predictable types.
        
    
    **Better Refactoring**
    
    * Changing a type propagates errors/warnings across the codebase, helping avoid bugs.
        

---

## ğŸ“Š Quick Summary

| Feature | Description |
| --- | --- |
| **Type** | Defines what kind of data a variable/function can hold |
| **Types in TS** | Primitive (number, string, boolean, etc.), Special (`any`, `void`, `never`), Advanced (`array`, `tuple`, `enum`, `interface`, `type`) |
| **Purpose** | Safety, readability, better tooling (IntelliSense), scalability, refactoring |

ğŸ‘ **TypeScript Types Cheatsheet** ğŸ“’ â€” with categories, definitions, and examples for quick reference.

---

## ğŸ“˜ TypeScript Types Cheatsheet

## ğŸ”¹ 1. Primitive Types

| Type | Description | Example |
| --- | --- | --- |
| `number` | Numeric values (int, float, hex, binary) | `let age: number = 25;` |
| `string` | Text values | `let name: string = "Nini";` |
| `boolean` | True/False | `let isAdmin: boolean = true;` |
| `null` | Null value | `let x: null = null;` |
| `undefined` | Undefined value | `let y: undefined = undefined;` |
| `bigint` | Very large integers | `let big: bigint = 9007199254740991n;` |
| `symbol` | Unique identifier | `let sym: symbol = Symbol("id");` |

## ğŸ”¹ 2. Special Types

| Type | Description | Example |
| --- | --- | --- |
| `any` | Can be **anything** (disables type checking) | `let data: any = "text"; data = 123;` |
| `unknown` | Like `any` but safer (must check type first) | `let val: unknown = "hi"; if (typeof val === "string") console.log(val.toUpperCase());` |
| `void` | No return value (usually for functions) | `function log(msg: string): void { console.log(msg); }` |
| `never` | Function never returns (infinite loop or error) | `function fail(): never { throw new Error("Error!"); }` |
| `object` | Any non-primitive object | `let obj: object = {name: "Nini"};` |

## ğŸ”¹ 3. Structured Types

| Type | Description | Example |
| --- | --- | --- |
| `array` | Collection of same type | `let nums: number[] = [1, 2, 3];` |
| `tuple` | Fixed-size array with specific types | `let tupleEx: [string, number] = ["Age", 25];` |
| `enum` | Named constants | `enum Role { Admin, User, Guest } let r: Role = Role.Admin;` |

## ğŸ”¹ 4. Function Types

| Type | Description | Example |
| --- | --- | --- |
| Function parameters & return | Explicit typing of arguments and return value | `function add(a: number, b: number): number { return a + b; }` |
| Optional parameter | Parameter may or may not be provided | \`function greet(name?: string) { return "Hi " + (name |
| Default parameter | Has a default value | `function greet(name: string = "Guest") { return "Hi " + name; }` |

## ğŸ”¹ 5. Advanced Types

| Type | Description | Example |
| --- | --- | --- |
| `union` | Multiple possible types | `let id: number | string; id = 101; id = "ABC";` |
| `intersection` | Combine multiple types | `type A = {x: number}; type B = {y: string}; let obj: A & B = {x: 1, y: "hi"};` |
| `type alias` | Custom name for a type | `type ID = number | string; let userId: ID = 123;` |
| `interface` | Structure for objects/classes | `interface User { id: number; name: string; } let u: User = {id: 1, name: "Nini"};` |
| `literal` | Specific allowed values | `let status: "success" | "error"; status = "success";` |
| `generics` | Reusable type placeholders | `function identity<T>(arg: T): T { return arg; } let output = identity<string>("Hello");` |

# **05 Type Annotations**

## ğŸ”¹ What is Type Annotation in TypeScript?

**Type annotation** is when you explicitly **declare the type** of a **variable**, **constant**, **function parameter**, or **return type**.

* It tells the compiler: â€œThis **variable** should **only** hold values of this type.â€
    
* TypeScript will throw an error if you try to assign a value of a different type.
    

Syntax:

```typescript
let variableName: type = value;
```

---

## ğŸ”¹ Type Annotations in Variables and Constants

### 1\. Variables

```typescript
let age: number = 25;          // number type
let name: string = "Nini";     // string type
let isAdmin: boolean = true;   // boolean type
```

### 2\. Constants

```typescript
const userName: string = "Nini"; // string constant
const pi: number = 3.14;         // number constant
```

> âš¡ Note: Constants with `const` must be initialized when declared.

---

## ğŸ”¹ Type Annotation Examples

### 1\. Arrays

```typescript
let numbers: number[] = [1, 2, 3];
let names: string[] = ["Nini", "Alice"];
```

### 2\. Tuples

```typescript
let user: [string, number] = ["Nini", 25]; // fixed-size: name + age
```

### 3\. Functions

```typescript
function greet(name: string): string {
    return "Hello, " + name;
}

console.log(greet("Nini"));
```

### 4\. Objects

```typescript
let person: { name: string; age: number; isAdmin: boolean } = {
    name: "Nini",
    age: 25,
    isAdmin: true
};
```

### 5\. Union Types

```typescript
let id: number | string;
id = 101;
id = "Nini123";
```

### 6\. Any / Unknown

```typescript
let data: any = 42;
data = "Nini";   // âœ… allowed

let unknownData: unknown = "Nini";
// unknownData.toUpperCase(); âŒ ERROR: Type must be checked first
if (typeof unknownData === "string") {
    console.log(unknownData.toUpperCase()); // âœ… safe
}
```

---

## ğŸ”¹ Summary

| Feature | Example |
| --- | --- |
| Variable Annotation | `let name: string = "Nini";` |
| Constant Annotation | `const userName: string = "Nini";` |
| Array Annotation | `let names: string[] = ["Nini"];` |
| Tuple | `let user: [string, number] = ["Nini", 25];` |
| Object Annotation | `let person: { name: string; age: number } = { name: "Nini", age: 25 };` |
| Function Parameter & Return | `function greet(name: string): string { return "Hello, " + name; }` |
| Union Type | \`let id: number |
| Any / Unknown | `let data: any = "Nini";` |

# **06 Type Inference**

## ğŸ”¹ 1. Basic Type Inference

**Type inference** is when TypeScript **automatically determines the type** of a variable based on its value, without an explicit type annotation.

âœ… Example:

```typescript
let name = "Nini";    // TypeScript infers type as string
let age = 25;         // inferred as number
let isAdmin = true;   // inferred as boolean
```

> You donâ€™t need to write `:string` or `:number` here.  
> TypeScript guesses the type from the assigned value.

---

## ğŸ”¹ 2. The Best Common Type Algorithm

* TypeScript tries to **find a single type that works for multiple values**.
    
* If values have **different types**, TypeScript tries to pick a **common type**.
    

âœ… Example:

```typescript
let arr = ["Nini", "Alice", "Bob"]; // inferred as string[]
let mixed = [1, 2, "Nini"];         // inferred as (string | number)[]
```

> TypeScript looks at all elements and picks the **best common type** that fits all values.

---

## ğŸ”¹ 3. Contextual Typing

* TypeScript can **infer types from context**, like function parameters or object properties.
    
* The type is **not explicit**, but TypeScript knows it based on where the value is used.
    

âœ… Example:

```typescript
window.onmousedown = function(event) {
    console.log(event.button); // event is inferred as MouseEvent
};

let greet: (name: string) => string = function(n) {
    return "Hello, " + n;
};
console.log(greet("Nini"));
```

> The compiler infers `event` and `n` types from context.

---

## ğŸ”¹ 4. Type Inference vs Type Annotations

| Feature | Type Inference | Type Annotation |
| --- | --- | --- |
| Explicitly written? | âŒ No | âœ… Yes |
| Compiler assigns type? | âœ… Yes, automatically | âŒ You specify it |
| Example | `let age = 25; // inferred as number` | `let age: number = 25;` |
| Use Case | Quick, safe for simple cases | Needed for complex types, clarity, or API contracts |
| Flexibility | Less typing, but still safe | Guarantees exact type, prevents mistakes |

---

## ğŸ”¹ 5. Summary

* **Type Inference** â†’ TypeScript guesses the type based on value or context.
    
* **Best Common Type Algorithm** â†’ Picks a type that fits all elements in arrays or unions.
    
* **Contextual Typing** â†’ Type inferred based on usage (like parameters or events).
    
* **Type Inference vs Type Annotation** â†’ Inference = automatic, Annotation = explicit.
    

âœ… Example combining everything:

```typescript
let name = "Nini";                    // inferred string
let mixed: (string | number)[] = [1, "Nini"]; // explicit union type
function greet(n: string) {           // type annotation
    console.log("Hello, " + n);
}
let clickHandler = (event) => {       // contextual typing
    console.log(event.button);
};
```